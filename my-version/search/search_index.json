{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Electricity Trading API Client","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Electricity Trading API client for Python</p>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>The following platforms are officially supported (tested):</p> <ul> <li>Python: 3.11</li> <li>Operating System: Ubuntu Linux 20.04</li> <li>Architectures: amd64, arm64</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Electricity Trading API Client","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>client<ul> <li>electricity_trading</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/client/electricity_trading/","title":"electricity_trading","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading","title":"frequenz.client.electricity_trading","text":"<p>Electricity Trading API client for Python.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading-classes","title":"Classes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client","title":"frequenz.client.electricity_trading.Client","text":"<p>Electricity trading client.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>class Client:\n\"\"\"Electricity trading client.\"\"\"\ndef __init__(self, grpc_channel: grpc.aio.Channel) -&gt; None:\n\"\"\"Initialize the client.\n        Args:\n            grpc_channel: gRPC channel to use for communication with the API.\n        \"\"\"\nself._stub = electricity_trading_pb2_grpc.ElectricityTradingServiceStub(\ngrpc_channel\n)\nself._gridpool_orders_streams: dict[\ntuple[int, GridpoolOrderFilter],\nGrpcStreamingHelper[\nelectricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n],\n] = {}\nself._gridpool_trades_streams: dict[\ntuple[int, GridpoolTradeFilter],\nGrpcStreamingHelper[\nelectricity_trading_pb2.ReceiveGridpoolTradesStreamResponse, Trade\n],\n] = {}\nself._public_trades_streams: dict[\nPublicTradeFilter,\nGrpcStreamingHelper[\nelectricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n],\n] = {}\nasync def stream_gridpool_orders(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\norder_states: list[OrderState] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_area: DeliveryArea | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ntag: str | None = None,\n) -&gt; Receiver[OrderDetail]:\n\"\"\"\n        Stream gridpool orders.\n        Args:\n            gridpool_id: ID of the gridpool to stream orders for.\n            order_states: List of order states to filter for.\n            market_side: Market side to filter for.\n            delivery_area: Delivery area to filter for.\n            delivery_period: Delivery period to filter for.\n            tag: Tag to filter for.\n        Returns:\n            Async generator of orders.\n        Raises:\n            grpc.RpcError: If an error occurs while streaming the orders.\n        \"\"\"\ngridpool_order_filter = GridpoolOrderFilter(\norder_states=order_states,\nside=market_side,\ndelivery_area=delivery_area,\ndelivery_period=delivery_period,\ntag=tag,\n)\nstream_key = (gridpool_id, gridpool_order_filter)\nif stream_key not in self._gridpool_orders_streams:\ntry:\nself._gridpool_orders_streams[stream_key] = GrpcStreamingHelper(\nf\"electricity-trading-{stream_key}\",\nlambda: self._stub.ReceiveGridpoolOrdersStream(  # type: ignore\nelectricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_order_filter.to_pb(),\n)\n),\nlambda response: OrderDetail.from_pb(response.order_detail),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\n\"Error occurred while streaming gridpool orders: %s\", e\n)\nraise e\nreturn self._gridpool_orders_streams[stream_key].new_receiver()\nasync def stream_gridpool_trades(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\ntrade_states: list[TradeState] | None = None,\ntrade_ids: list[int] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[Trade]:\n\"\"\"\n        Stream gridpool trades.\n        Args:\n            gridpool_id: The ID of the gridpool to stream trades for.\n            trade_states: List of trade states to filter for.\n            trade_ids: List of trade IDs to filter for.\n            market_side: The market side to filter for.\n            delivery_period: The delivery period to filter for.\n            delivery_area: The delivery area to filter for.\n        Returns:\n            The gridpool trades streamer.\n        Raises:\n            grpc.RpcError: If an error occurs while streaming gridpool trades.\n        \"\"\"\ngridpool_trade_filter = GridpoolTradeFilter(\ntrade_states=trade_states,\ntrade_ids=trade_ids,\nside=market_side,\ndelivery_period=delivery_period,\ndelivery_area=delivery_area,\n)\nstream_key = (gridpool_id, gridpool_trade_filter)\nif stream_key not in self._gridpool_trades_streams:\ntry:\nself._gridpool_trades_streams[stream_key] = GrpcStreamingHelper(\nf\"electricity-trading-{stream_key}\",\nlambda: self._stub.ReceiveGridpoolTradesStream(  # type: ignore\nelectricity_trading_pb2.ReceiveGridpoolTradesStreamRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_trade_filter.to_pb(),\n)\n),\nlambda response: Trade.from_pb(response.trade),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\n\"Error occurred while streaming gridpool trades: %s\", e\n)\nraise e\nreturn self._gridpool_trades_streams[stream_key].new_receiver()\nasync def stream_public_trades(\nself,\nstates: list[TradeState] | None = None,\ndelivery_period: DeliveryPeriod | None = None,\nbuy_delivery_area: DeliveryArea | None = None,\nsell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]:\n\"\"\"\n        Stream public trades.\n        Args:\n            states: List of order states to filter for.\n            delivery_period: Delivery period to filter for.\n            buy_delivery_area: Buy delivery area to filter for.\n            sell_delivery_area: Sell delivery area to filter for.\n        Returns:\n            Async generator of orders.\n        Raises:\n            grpc.RpcError: If an error occurs while streaming public trades.\n        \"\"\"\npublic_trade_filter = PublicTradeFilter(\nstates=states,\ndelivery_period=delivery_period,\nbuy_delivery_area=buy_delivery_area,\nsell_delivery_area=sell_delivery_area,\n)\nif public_trade_filter not in self._public_trades_streams:\ntry:\nself._public_trades_streams[public_trade_filter] = GrpcStreamingHelper(\nf\"electricity-trading-{public_trade_filter}\",\nlambda: self._stub.ReceivePublicTradesStream(  # type: ignore\nelectricity_trading_pb2.ReceivePublicTradesStreamRequest(\nfilter=public_trade_filter.to_pb(),\n)\n),\nlambda response: PublicTrade.from_pb(response.public_trade),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while streaming public trades: %s\", e)\nraise e\nreturn self._public_trades_streams[public_trade_filter].new_receiver()\nasync def create_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\nself,\ngridpool_id: int,\ndelivery_area: DeliveryArea,\ndelivery_period: DeliveryPeriod,\norder_type: OrderType,\nside: MarketSide,\nprice: Price,\nquantity: Energy,\nstop_price: Price | None = None,\npeak_price_delta: Price | None = None,\ndisplay_quantity: Energy | None = None,\nexecution_option: OrderExecutionOption | None = None,\nvalid_until: datetime | None = None,\npayload: dict[str, struct_pb2.Value] | None = None,\ntag: str | None = None,\n) -&gt; OrderDetail:\n\"\"\"\n        Create a gridpool order.\n        Args:\n            gridpool_id: ID of the gridpool to create the order for.\n            delivery_area: Delivery area of the order.\n            delivery_period: Delivery period of the order.\n            order_type: Type of the order.\n            side: Side of the order.\n            price: Price of the order.\n            quantity: Quantity of the order.\n            stop_price: Stop price of the order.\n            peak_price_delta: Peak price delta of the order.\n            display_quantity: Display quantity of the order.\n            execution_option: Execution option of the order.\n            valid_until: Valid until of the order.\n            payload: Payload of the order.\n            tag: Tag of the order.\n        Returns:\n            The created order.\n        Raises:\n            grpc.RpcError: An error occurred while creating the order.\n        \"\"\"\norder = Order(\ndelivery_area=delivery_area,\ndelivery_period=delivery_period,\ntype=order_type,\nside=side,\nprice=price,\nquantity=quantity,\nstop_price=stop_price,\npeak_price_delta=peak_price_delta,\ndisplay_quantity=display_quantity,\nexecution_option=execution_option,\nvalid_until=valid_until,\npayload=payload,\ntag=tag,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\nself._stub.CreateGridpoolOrder(\nelectricity_trading_pb2.CreateGridpoolOrderRequest(\ngridpool_id=gridpool_id,\norder=order.to_pb(),\n)\n),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while creating gridpool order: %s\", e)\nraise e\nreturn OrderDetail.from_pb(response.order_detail)\nasync def update_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\nself,\ngridpool_id: int,\norder_id: int,\nprice: Price | None | _Sentinel = NO_VALUE,\nquantity: Energy | None | _Sentinel = NO_VALUE,\nstop_price: Price | None | _Sentinel = NO_VALUE,\npeak_price_delta: Price | None | _Sentinel = NO_VALUE,\ndisplay_quantity: Energy | None | _Sentinel = NO_VALUE,\nexecution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\nvalid_until: datetime | None | _Sentinel = NO_VALUE,\npayload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\ntag: str | None | _Sentinel = NO_VALUE,\n) -&gt; OrderDetail:\n\"\"\"\n        Update an existing order for a given Gridpool.\n        Args:\n            gridpool_id: ID of the Gridpool the order belongs to.\n            order_id: Order ID.\n            price: The updated limit price at which the contract is to be traded.\n                This is the maximum price for a BUY order or the minimum price for a SELL order.\n            quantity: The updated quantity of the contract being traded, specified in MWh.\n            stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n                triggers the limit order.\n            peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n                between the peak price and the limit price.\n            display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n                order to be displayed in the order book.\n            execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n            valid_until: This is an updated timestamp defining the time after which the order\n                should be cancelled if not filled. The timestamp is in UTC.\n            payload: Updated user-defined payload individual to a specific order. This can be any\n                data that the user wants to associate with the order.\n            tag: Updated user-defined tag to group related orders.\n        Returns:\n            The updated order.\n        Raises:\n            ValueError: If no fields to update are provided.\n        \"\"\"\nparams = {\n\"price\": price,\n\"quantity\": quantity,\n\"stop_price\": stop_price,\n\"peak_price_delta\": peak_price_delta,\n\"display_quantity\": display_quantity,\n\"execution_option\": execution_option,\n\"valid_until\": valid_until,\n\"payload\": payload,\n\"tag\": tag,\n}\nif all(value is NO_VALUE for value in params.values()):\nraise ValueError(\"At least one field to update must be provided.\")\npaths = [param for param, value in params.items() if value is not NO_VALUE]\n# Field mask specifying which fields should be updated\n# This is used so that we can update parameters with None values\nupdate_mask = field_mask_pb2.FieldMask(paths=paths)\nupdate_order_fields = UpdateOrder(\nprice=None if price is NO_VALUE else price,  # type: ignore\nquantity=None if quantity is NO_VALUE else quantity,  # type: ignore\nstop_price=None if stop_price is NO_VALUE else stop_price,  # type: ignore\npeak_price_delta=None\nif peak_price_delta is NO_VALUE\nelse peak_price_delta,  # type: ignore\ndisplay_quantity=None\nif display_quantity is NO_VALUE\nelse display_quantity,  # type: ignore\nexecution_option=None\nif execution_option is NO_VALUE\nelse execution_option,  # type: ignore\nvalid_until=None\nif valid_until is NO_VALUE\nelse valid_until,  # type: ignore\npayload=None if payload is NO_VALUE else payload,  # type: ignore\ntag=None if tag is NO_VALUE else tag,  # type: ignore\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\nself._stub.UpdateGridpoolOrder(\nelectricity_trading_pb2.UpdateGridpoolOrderRequest(\ngridpool_id=gridpool_id,\norder_id=order_id,\nupdate_order_fields=update_order_fields.to_pb(),\nupdate_mask=update_mask,\n)\n),\n)\nreturn OrderDetail.from_pb(response.order_detail)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while updating gridpool order: %s\", e)\nraise e\nasync def cancel_gridpool_order(\nself, gridpool_id: int, order_id: int\n) -&gt; OrderDetail:\n\"\"\"\n        Cancel a single order for a given Gridpool.\n        Args:\n            gridpool_id: The Gridpool to cancel the order for.\n            order_id: The order to cancel.\n        Returns:\n            The cancelled order.\n        Raises:\n            grpc.RpcError: If an error occurs while cancelling the gridpool order.\n        \"\"\"\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\nself._stub.CancelGridpoolOrder(\nelectricity_trading_pb2.CancelGridpoolOrderRequest(\ngridpool_id=gridpool_id, order_id=order_id\n)\n),\n)\nreturn OrderDetail.from_pb(response.order_detail)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while cancelling gridpool order: %s\", e)\nraise e\nasync def cancel_all_gridpool_orders(self, gridpool_id: int) -&gt; int:\n\"\"\"\n        Cancel all orders for a specific Gridpool.\n        Args:\n            gridpool_id: The Gridpool to cancel the orders for.\n        Returns:\n            The ID of the Gridpool for which the orders were cancelled.\n        Raises:\n            grpc.RpcError: If an error occurs while cancelling all gridpool orders.\n        \"\"\"\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\nself._stub.CancelAllGridpoolOrders(\nelectricity_trading_pb2.CancelAllGridpoolOrdersRequest(\ngridpool_id=gridpool_id\n)\n),\n)\nreturn response.gridpool_id\nexcept grpc.RpcError as e:\n_logger.exception(\n\"Error occurred while cancelling all gridpool orders: %s\", e\n)\nraise e\nasync def get_gridpool_order(self, gridpool_id: int, order_id: int) -&gt; OrderDetail:\n\"\"\"\n        Get a single order from a given gridpool.\n        Args:\n            gridpool_id: The Gridpool to retrieve the order for.\n            order_id: The order to retrieve.\n        Returns:\n            The order.\n        Raises:\n            grpc.RpcError: If an error occurs while getting the order.\n        \"\"\"\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\nself._stub.GetGridpoolOrder(\nelectricity_trading_pb2.GetGridpoolOrderRequest(\ngridpool_id=gridpool_id, order_id=order_id\n)\n),\n)\nreturn OrderDetail.from_pb(response.order_detail)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while getting gridpool order: %s\", e)\nraise e\nasync def list_gridpool_orders(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\norder_states: list[OrderState] | None = None,\nside: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\ntag: str | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[OrderDetail]:\n\"\"\"\n        List orders for a specific Gridpool with optional filters.\n        Args:\n            gridpool_id: The Gridpool to retrieve the orders for.\n            order_states: List of order states to filter by.\n            side: The side of the market to filter by.\n            delivery_period: The delivery period to filter by.\n            delivery_area: The delivery area to filter by.\n            tag: The tag to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n        Returns:\n            The list of orders for that gridpool.\n        Raises:\n            grpc.RpcError: If an error occurs while listing the orders.\n        \"\"\"\ngridpool_order_filer = GridpoolOrderFilter(\norder_states=order_states,\nside=side,\ndelivery_period=delivery_period,\ndelivery_area=delivery_area,\ntag=tag,\n)\npagination_params = PaginationParams(\npage_size=max_nr_orders,\npage_token=page_token,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\nself._stub.ListGridpoolOrders(\nelectricity_trading_pb2.ListGridpoolOrdersRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_order_filer.to_pb(),\npagination_params=pagination_params.to_pb(),\n)\n),\n)\nreturn [\nOrderDetail.from_pb(order_detail)\nfor order_detail in response.order_details\n]\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while listing gridpool orders: %s\", e)\nraise e\nasync def list_gridpool_trades(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\ntrade_states: list[TradeState] | None = None,\ntrade_ids: list[int] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[Trade]:\n\"\"\"\n        List trades for a specific Gridpool with optional filters.\n        Args:\n            gridpool_id: The Gridpool to retrieve the trades for.\n            trade_states: List of trade states to filter by.\n            trade_ids: List of trade IDs to filter by.\n            market_side: The side of the market to filter by.\n            delivery_period: The delivery period to filter by.\n            delivery_area: The delivery area to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n        Returns:\n            The list of trades for the given gridpool.\n        Raises:\n            grpc.RpcError: If an error occurs while listing gridpool trades.\n        \"\"\"\ngridpool_trade_filter = GridpoolTradeFilter(\ntrade_states=trade_states,\ntrade_ids=trade_ids,\nside=market_side,\ndelivery_period=delivery_period,\ndelivery_area=delivery_area,\n)\npagination_params = PaginationParams(\npage_size=max_nr_orders,\npage_token=page_token,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.ListGridpoolTradesResponse],\nself._stub.ListGridpoolTrades(\nelectricity_trading_pb2.ListGridpoolTradesRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_trade_filter.to_pb(),\npagination_params=pagination_params.to_pb(),\n)\n),\n)\nreturn [Trade.from_pb(trade) for trade in response.trades]\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while listing gridpool trades: %s\", e)\nraise e\nasync def list_public_trades(  # pylint: disable=too-many-arguments\nself,\nstates: list[TradeState] | None = None,\ndelivery_period: DeliveryPeriod | None = None,\nbuy_delivery_area: DeliveryArea | None = None,\nsell_delivery_area: DeliveryArea | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[PublicTrade]:\n\"\"\"\n        List all executed public orders with optional filters.\n        Args:\n            states: List of order states to filter by.\n            delivery_period: The delivery period to filter by.\n            buy_delivery_area: The buy delivery area to filter by.\n            sell_delivery_area: The sell delivery area to filter by.\n            max_nr_orders: The maximum number of orders to return.\n            page_token: The page token to use for pagination.\n        Returns:\n            The list of public trades.\n        Raises:\n            grpc.RpcError: If an error occurs while listing public trades.\n        \"\"\"\npublic_trade_filter = PublicTradeFilter(\nstates=states,\ndelivery_period=delivery_period,\nbuy_delivery_area=buy_delivery_area,\nsell_delivery_area=sell_delivery_area,\n)\npagination_params = PaginationParams(\npage_size=max_nr_orders,\npage_token=page_token,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.ListPublicTradesResponse],\nself._stub.ListPublicTrades(\nelectricity_trading_pb2.ListPublicTradesRequest(\nfilter=public_trade_filter.to_pb(),\npagination_params=pagination_params.to_pb(),\n)\n),\n)\nreturn [\nPublicTrade.from_pb(public_trade)\nfor public_trade in response.public_trades\n]\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while listing public trades: %s\", e)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.__init__","title":"__init__","text":"<pre><code>__init__(grpc_channel: Channel) -&gt; None\n</code></pre> <p>Initialize the client.</p> PARAMETER  DESCRIPTION <code>grpc_channel</code> <p>gRPC channel to use for communication with the API.</p> <p> TYPE: <code>Channel</code> </p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>def __init__(self, grpc_channel: grpc.aio.Channel) -&gt; None:\n\"\"\"Initialize the client.\n    Args:\n        grpc_channel: gRPC channel to use for communication with the API.\n    \"\"\"\nself._stub = electricity_trading_pb2_grpc.ElectricityTradingServiceStub(\ngrpc_channel\n)\nself._gridpool_orders_streams: dict[\ntuple[int, GridpoolOrderFilter],\nGrpcStreamingHelper[\nelectricity_trading_pb2.ReceiveGridpoolOrdersStreamResponse, OrderDetail\n],\n] = {}\nself._gridpool_trades_streams: dict[\ntuple[int, GridpoolTradeFilter],\nGrpcStreamingHelper[\nelectricity_trading_pb2.ReceiveGridpoolTradesStreamResponse, Trade\n],\n] = {}\nself._public_trades_streams: dict[\nPublicTradeFilter,\nGrpcStreamingHelper[\nelectricity_trading_pb2.ReceivePublicTradesStreamResponse, PublicTrade\n],\n] = {}\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_all_gridpool_orders","title":"cancel_all_gridpool_orders  <code>async</code>","text":"<pre><code>cancel_all_gridpool_orders(gridpool_id: int) -&gt; int\n</code></pre> <p>Cancel all orders for a specific Gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the orders for.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The ID of the Gridpool for which the orders were cancelled.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while cancelling all gridpool orders.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_all_gridpool_orders(self, gridpool_id: int) -&gt; int:\n\"\"\"\n    Cancel all orders for a specific Gridpool.\n    Args:\n        gridpool_id: The Gridpool to cancel the orders for.\n    Returns:\n        The ID of the Gridpool for which the orders were cancelled.\n    Raises:\n        grpc.RpcError: If an error occurs while cancelling all gridpool orders.\n    \"\"\"\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.CancelAllGridpoolOrdersResponse],\nself._stub.CancelAllGridpoolOrders(\nelectricity_trading_pb2.CancelAllGridpoolOrdersRequest(\ngridpool_id=gridpool_id\n)\n),\n)\nreturn response.gridpool_id\nexcept grpc.RpcError as e:\n_logger.exception(\n\"Error occurred while cancelling all gridpool orders: %s\", e\n)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.cancel_gridpool_order","title":"cancel_gridpool_order  <code>async</code>","text":"<pre><code>cancel_gridpool_order(\ngridpool_id: int, order_id: int\n) -&gt; OrderDetail\n</code></pre> <p>Cancel a single order for a given Gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to cancel the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to cancel.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The cancelled order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while cancelling the gridpool order.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def cancel_gridpool_order(\nself, gridpool_id: int, order_id: int\n) -&gt; OrderDetail:\n\"\"\"\n    Cancel a single order for a given Gridpool.\n    Args:\n        gridpool_id: The Gridpool to cancel the order for.\n        order_id: The order to cancel.\n    Returns:\n        The cancelled order.\n    Raises:\n        grpc.RpcError: If an error occurs while cancelling the gridpool order.\n    \"\"\"\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.CancelGridpoolOrderResponse],\nself._stub.CancelGridpoolOrder(\nelectricity_trading_pb2.CancelGridpoolOrderRequest(\ngridpool_id=gridpool_id, order_id=order_id\n)\n),\n)\nreturn OrderDetail.from_pb(response.order_detail)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while cancelling gridpool order: %s\", e)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.create_gridpool_order","title":"create_gridpool_order  <code>async</code>","text":"<pre><code>create_gridpool_order(\ngridpool_id: int,\ndelivery_area: DeliveryArea,\ndelivery_period: DeliveryPeriod,\norder_type: OrderType,\nside: MarketSide,\nprice: Price,\nquantity: Energy,\nstop_price: Price | None = None,\npeak_price_delta: Price | None = None,\ndisplay_quantity: Energy | None = None,\nexecution_option: OrderExecutionOption | None = None,\nvalid_until: datetime | None = None,\npayload: dict[str, Value] | None = None,\ntag: str | None = None,\n) -&gt; OrderDetail\n</code></pre> <p>Create a gridpool order.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to create the order for.</p> <p> TYPE: <code>int</code> </p> <code>delivery_area</code> <p>Delivery area of the order.</p> <p> TYPE: <code>DeliveryArea</code> </p> <code>delivery_period</code> <p>Delivery period of the order.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> <code>order_type</code> <p>Type of the order.</p> <p> TYPE: <code>OrderType</code> </p> <code>side</code> <p>Side of the order.</p> <p> TYPE: <code>MarketSide</code> </p> <code>price</code> <p>Price of the order.</p> <p> TYPE: <code>Price</code> </p> <code>quantity</code> <p>Quantity of the order.</p> <p> TYPE: <code>Energy</code> </p> <code>stop_price</code> <p>Stop price of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>peak_price_delta</code> <p>Peak price delta of the order.</p> <p> TYPE: <code>Price | None</code> DEFAULT: <code>None</code> </p> <code>display_quantity</code> <p>Display quantity of the order.</p> <p> TYPE: <code>Energy | None</code> DEFAULT: <code>None</code> </p> <code>execution_option</code> <p>Execution option of the order.</p> <p> TYPE: <code>OrderExecutionOption | None</code> DEFAULT: <code>None</code> </p> <code>valid_until</code> <p>Valid until of the order.</p> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> <code>payload</code> <p>Payload of the order.</p> <p> TYPE: <code>dict[str, Value] | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag of the order.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The created order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>An error occurred while creating the order.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def create_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\nself,\ngridpool_id: int,\ndelivery_area: DeliveryArea,\ndelivery_period: DeliveryPeriod,\norder_type: OrderType,\nside: MarketSide,\nprice: Price,\nquantity: Energy,\nstop_price: Price | None = None,\npeak_price_delta: Price | None = None,\ndisplay_quantity: Energy | None = None,\nexecution_option: OrderExecutionOption | None = None,\nvalid_until: datetime | None = None,\npayload: dict[str, struct_pb2.Value] | None = None,\ntag: str | None = None,\n) -&gt; OrderDetail:\n\"\"\"\n    Create a gridpool order.\n    Args:\n        gridpool_id: ID of the gridpool to create the order for.\n        delivery_area: Delivery area of the order.\n        delivery_period: Delivery period of the order.\n        order_type: Type of the order.\n        side: Side of the order.\n        price: Price of the order.\n        quantity: Quantity of the order.\n        stop_price: Stop price of the order.\n        peak_price_delta: Peak price delta of the order.\n        display_quantity: Display quantity of the order.\n        execution_option: Execution option of the order.\n        valid_until: Valid until of the order.\n        payload: Payload of the order.\n        tag: Tag of the order.\n    Returns:\n        The created order.\n    Raises:\n        grpc.RpcError: An error occurred while creating the order.\n    \"\"\"\norder = Order(\ndelivery_area=delivery_area,\ndelivery_period=delivery_period,\ntype=order_type,\nside=side,\nprice=price,\nquantity=quantity,\nstop_price=stop_price,\npeak_price_delta=peak_price_delta,\ndisplay_quantity=display_quantity,\nexecution_option=execution_option,\nvalid_until=valid_until,\npayload=payload,\ntag=tag,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.CreateGridpoolOrderResponse],\nself._stub.CreateGridpoolOrder(\nelectricity_trading_pb2.CreateGridpoolOrderRequest(\ngridpool_id=gridpool_id,\norder=order.to_pb(),\n)\n),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while creating gridpool order: %s\", e)\nraise e\nreturn OrderDetail.from_pb(response.order_detail)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.get_gridpool_order","title":"get_gridpool_order  <code>async</code>","text":"<pre><code>get_gridpool_order(\ngridpool_id: int, order_id: int\n) -&gt; OrderDetail\n</code></pre> <p>Get a single order from a given gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the order for.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>The order to retrieve.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The order.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while getting the order.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def get_gridpool_order(self, gridpool_id: int, order_id: int) -&gt; OrderDetail:\n\"\"\"\n    Get a single order from a given gridpool.\n    Args:\n        gridpool_id: The Gridpool to retrieve the order for.\n        order_id: The order to retrieve.\n    Returns:\n        The order.\n    Raises:\n        grpc.RpcError: If an error occurs while getting the order.\n    \"\"\"\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.GetGridpoolOrderResponse],\nself._stub.GetGridpoolOrder(\nelectricity_trading_pb2.GetGridpoolOrderRequest(\ngridpool_id=gridpool_id, order_id=order_id\n)\n),\n)\nreturn OrderDetail.from_pb(response.order_detail)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while getting gridpool order: %s\", e)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_gridpool_orders","title":"list_gridpool_orders  <code>async</code>","text":"<pre><code>list_gridpool_orders(\ngridpool_id: int,\norder_states: list[OrderState] | None = None,\nside: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\ntag: str | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[OrderDetail]\n</code></pre> <p>List orders for a specific Gridpool with optional filters.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the orders for.</p> <p> TYPE: <code>int</code> </p> <code>order_states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>side</code> <p>The side of the market to filter by.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>The tag to filter by.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[OrderDetail]</code> <p>The list of orders for that gridpool.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing the orders.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_gridpool_orders(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\norder_states: list[OrderState] | None = None,\nside: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\ntag: str | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[OrderDetail]:\n\"\"\"\n    List orders for a specific Gridpool with optional filters.\n    Args:\n        gridpool_id: The Gridpool to retrieve the orders for.\n        order_states: List of order states to filter by.\n        side: The side of the market to filter by.\n        delivery_period: The delivery period to filter by.\n        delivery_area: The delivery area to filter by.\n        tag: The tag to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n    Returns:\n        The list of orders for that gridpool.\n    Raises:\n        grpc.RpcError: If an error occurs while listing the orders.\n    \"\"\"\ngridpool_order_filer = GridpoolOrderFilter(\norder_states=order_states,\nside=side,\ndelivery_period=delivery_period,\ndelivery_area=delivery_area,\ntag=tag,\n)\npagination_params = PaginationParams(\npage_size=max_nr_orders,\npage_token=page_token,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.ListGridpoolOrdersResponse],\nself._stub.ListGridpoolOrders(\nelectricity_trading_pb2.ListGridpoolOrdersRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_order_filer.to_pb(),\npagination_params=pagination_params.to_pb(),\n)\n),\n)\nreturn [\nOrderDetail.from_pb(order_detail)\nfor order_detail in response.order_details\n]\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while listing gridpool orders: %s\", e)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_gridpool_trades","title":"list_gridpool_trades  <code>async</code>","text":"<pre><code>list_gridpool_trades(\ngridpool_id: int,\ntrade_states: list[TradeState] | None = None,\ntrade_ids: list[int] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[Trade]\n</code></pre> <p>List trades for a specific Gridpool with optional filters.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The Gridpool to retrieve the trades for.</p> <p> TYPE: <code>int</code> </p> <code>trade_states</code> <p>List of trade states to filter by.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>trade_ids</code> <p>List of trade IDs to filter by.</p> <p> TYPE: <code>list[int] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>The side of the market to filter by.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[Trade]</code> <p>The list of trades for the given gridpool.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing gridpool trades.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_gridpool_trades(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\ntrade_states: list[TradeState] | None = None,\ntrade_ids: list[int] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[Trade]:\n\"\"\"\n    List trades for a specific Gridpool with optional filters.\n    Args:\n        gridpool_id: The Gridpool to retrieve the trades for.\n        trade_states: List of trade states to filter by.\n        trade_ids: List of trade IDs to filter by.\n        market_side: The side of the market to filter by.\n        delivery_period: The delivery period to filter by.\n        delivery_area: The delivery area to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n    Returns:\n        The list of trades for the given gridpool.\n    Raises:\n        grpc.RpcError: If an error occurs while listing gridpool trades.\n    \"\"\"\ngridpool_trade_filter = GridpoolTradeFilter(\ntrade_states=trade_states,\ntrade_ids=trade_ids,\nside=market_side,\ndelivery_period=delivery_period,\ndelivery_area=delivery_area,\n)\npagination_params = PaginationParams(\npage_size=max_nr_orders,\npage_token=page_token,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.ListGridpoolTradesResponse],\nself._stub.ListGridpoolTrades(\nelectricity_trading_pb2.ListGridpoolTradesRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_trade_filter.to_pb(),\npagination_params=pagination_params.to_pb(),\n)\n),\n)\nreturn [Trade.from_pb(trade) for trade in response.trades]\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while listing gridpool trades: %s\", e)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.list_public_trades","title":"list_public_trades  <code>async</code>","text":"<pre><code>list_public_trades(\nstates: list[TradeState] | None = None,\ndelivery_period: DeliveryPeriod | None = None,\nbuy_delivery_area: DeliveryArea | None = None,\nsell_delivery_area: DeliveryArea | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[PublicTrade]\n</code></pre> <p>List all executed public orders with optional filters.</p> PARAMETER  DESCRIPTION <code>states</code> <p>List of order states to filter by.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter by.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>The buy delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>The sell delivery area to filter by.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>max_nr_orders</code> <p>The maximum number of orders to return.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>page_token</code> <p>The page token to use for pagination.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[PublicTrade]</code> <p>The list of public trades.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while listing public trades.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def list_public_trades(  # pylint: disable=too-many-arguments\nself,\nstates: list[TradeState] | None = None,\ndelivery_period: DeliveryPeriod | None = None,\nbuy_delivery_area: DeliveryArea | None = None,\nsell_delivery_area: DeliveryArea | None = None,\nmax_nr_orders: int | None = None,\npage_token: str | None = None,\n) -&gt; list[PublicTrade]:\n\"\"\"\n    List all executed public orders with optional filters.\n    Args:\n        states: List of order states to filter by.\n        delivery_period: The delivery period to filter by.\n        buy_delivery_area: The buy delivery area to filter by.\n        sell_delivery_area: The sell delivery area to filter by.\n        max_nr_orders: The maximum number of orders to return.\n        page_token: The page token to use for pagination.\n    Returns:\n        The list of public trades.\n    Raises:\n        grpc.RpcError: If an error occurs while listing public trades.\n    \"\"\"\npublic_trade_filter = PublicTradeFilter(\nstates=states,\ndelivery_period=delivery_period,\nbuy_delivery_area=buy_delivery_area,\nsell_delivery_area=sell_delivery_area,\n)\npagination_params = PaginationParams(\npage_size=max_nr_orders,\npage_token=page_token,\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.ListPublicTradesResponse],\nself._stub.ListPublicTrades(\nelectricity_trading_pb2.ListPublicTradesRequest(\nfilter=public_trade_filter.to_pb(),\npagination_params=pagination_params.to_pb(),\n)\n),\n)\nreturn [\nPublicTrade.from_pb(public_trade)\nfor public_trade in response.public_trades\n]\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while listing public trades: %s\", e)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_gridpool_orders","title":"stream_gridpool_orders  <code>async</code>","text":"<pre><code>stream_gridpool_orders(\ngridpool_id: int,\norder_states: list[OrderState] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_area: DeliveryArea | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ntag: str | None = None,\n) -&gt; Receiver[OrderDetail]\n</code></pre> <p>Stream gridpool orders.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>ID of the gridpool to stream orders for.</p> <p> TYPE: <code>int</code> </p> <code>order_states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[OrderState] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>Market side to filter for.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>Delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>tag</code> <p>Tag to filter for.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[OrderDetail]</code> <p>Async generator of orders.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming the orders.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_gridpool_orders(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\norder_states: list[OrderState] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_area: DeliveryArea | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ntag: str | None = None,\n) -&gt; Receiver[OrderDetail]:\n\"\"\"\n    Stream gridpool orders.\n    Args:\n        gridpool_id: ID of the gridpool to stream orders for.\n        order_states: List of order states to filter for.\n        market_side: Market side to filter for.\n        delivery_area: Delivery area to filter for.\n        delivery_period: Delivery period to filter for.\n        tag: Tag to filter for.\n    Returns:\n        Async generator of orders.\n    Raises:\n        grpc.RpcError: If an error occurs while streaming the orders.\n    \"\"\"\ngridpool_order_filter = GridpoolOrderFilter(\norder_states=order_states,\nside=market_side,\ndelivery_area=delivery_area,\ndelivery_period=delivery_period,\ntag=tag,\n)\nstream_key = (gridpool_id, gridpool_order_filter)\nif stream_key not in self._gridpool_orders_streams:\ntry:\nself._gridpool_orders_streams[stream_key] = GrpcStreamingHelper(\nf\"electricity-trading-{stream_key}\",\nlambda: self._stub.ReceiveGridpoolOrdersStream(  # type: ignore\nelectricity_trading_pb2.ReceiveGridpoolOrdersStreamRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_order_filter.to_pb(),\n)\n),\nlambda response: OrderDetail.from_pb(response.order_detail),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\n\"Error occurred while streaming gridpool orders: %s\", e\n)\nraise e\nreturn self._gridpool_orders_streams[stream_key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_gridpool_trades","title":"stream_gridpool_trades  <code>async</code>","text":"<pre><code>stream_gridpool_trades(\ngridpool_id: int,\ntrade_states: list[TradeState] | None = None,\ntrade_ids: list[int] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[Trade]\n</code></pre> <p>Stream gridpool trades.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>The ID of the gridpool to stream trades for.</p> <p> TYPE: <code>int</code> </p> <code>trade_states</code> <p>List of trade states to filter for.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>trade_ids</code> <p>List of trade IDs to filter for.</p> <p> TYPE: <code>list[int] | None</code> DEFAULT: <code>None</code> </p> <code>market_side</code> <p>The market side to filter for.</p> <p> TYPE: <code>MarketSide | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>The delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>delivery_area</code> <p>The delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[Trade]</code> <p>The gridpool trades streamer.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming gridpool trades.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_gridpool_trades(  # pylint: disable=too-many-arguments\nself,\ngridpool_id: int,\ntrade_states: list[TradeState] | None = None,\ntrade_ids: list[int] | None = None,\nmarket_side: MarketSide | None = None,\ndelivery_period: DeliveryPeriod | None = None,\ndelivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[Trade]:\n\"\"\"\n    Stream gridpool trades.\n    Args:\n        gridpool_id: The ID of the gridpool to stream trades for.\n        trade_states: List of trade states to filter for.\n        trade_ids: List of trade IDs to filter for.\n        market_side: The market side to filter for.\n        delivery_period: The delivery period to filter for.\n        delivery_area: The delivery area to filter for.\n    Returns:\n        The gridpool trades streamer.\n    Raises:\n        grpc.RpcError: If an error occurs while streaming gridpool trades.\n    \"\"\"\ngridpool_trade_filter = GridpoolTradeFilter(\ntrade_states=trade_states,\ntrade_ids=trade_ids,\nside=market_side,\ndelivery_period=delivery_period,\ndelivery_area=delivery_area,\n)\nstream_key = (gridpool_id, gridpool_trade_filter)\nif stream_key not in self._gridpool_trades_streams:\ntry:\nself._gridpool_trades_streams[stream_key] = GrpcStreamingHelper(\nf\"electricity-trading-{stream_key}\",\nlambda: self._stub.ReceiveGridpoolTradesStream(  # type: ignore\nelectricity_trading_pb2.ReceiveGridpoolTradesStreamRequest(\ngridpool_id=gridpool_id,\nfilter=gridpool_trade_filter.to_pb(),\n)\n),\nlambda response: Trade.from_pb(response.trade),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\n\"Error occurred while streaming gridpool trades: %s\", e\n)\nraise e\nreturn self._gridpool_trades_streams[stream_key].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.stream_public_trades","title":"stream_public_trades  <code>async</code>","text":"<pre><code>stream_public_trades(\nstates: list[TradeState] | None = None,\ndelivery_period: DeliveryPeriod | None = None,\nbuy_delivery_area: DeliveryArea | None = None,\nsell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]\n</code></pre> <p>Stream public trades.</p> PARAMETER  DESCRIPTION <code>states</code> <p>List of order states to filter for.</p> <p> TYPE: <code>list[TradeState] | None</code> DEFAULT: <code>None</code> </p> <code>delivery_period</code> <p>Delivery period to filter for.</p> <p> TYPE: <code>DeliveryPeriod | None</code> DEFAULT: <code>None</code> </p> <code>buy_delivery_area</code> <p>Buy delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> <code>sell_delivery_area</code> <p>Sell delivery area to filter for.</p> <p> TYPE: <code>DeliveryArea | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Receiver[PublicTrade]</code> <p>Async generator of orders.</p> RAISES DESCRIPTION <code>RpcError</code> <p>If an error occurs while streaming public trades.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def stream_public_trades(\nself,\nstates: list[TradeState] | None = None,\ndelivery_period: DeliveryPeriod | None = None,\nbuy_delivery_area: DeliveryArea | None = None,\nsell_delivery_area: DeliveryArea | None = None,\n) -&gt; Receiver[PublicTrade]:\n\"\"\"\n    Stream public trades.\n    Args:\n        states: List of order states to filter for.\n        delivery_period: Delivery period to filter for.\n        buy_delivery_area: Buy delivery area to filter for.\n        sell_delivery_area: Sell delivery area to filter for.\n    Returns:\n        Async generator of orders.\n    Raises:\n        grpc.RpcError: If an error occurs while streaming public trades.\n    \"\"\"\npublic_trade_filter = PublicTradeFilter(\nstates=states,\ndelivery_period=delivery_period,\nbuy_delivery_area=buy_delivery_area,\nsell_delivery_area=sell_delivery_area,\n)\nif public_trade_filter not in self._public_trades_streams:\ntry:\nself._public_trades_streams[public_trade_filter] = GrpcStreamingHelper(\nf\"electricity-trading-{public_trade_filter}\",\nlambda: self._stub.ReceivePublicTradesStream(  # type: ignore\nelectricity_trading_pb2.ReceivePublicTradesStreamRequest(\nfilter=public_trade_filter.to_pb(),\n)\n),\nlambda response: PublicTrade.from_pb(response.public_trade),\n)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while streaming public trades: %s\", e)\nraise e\nreturn self._public_trades_streams[public_trade_filter].new_receiver()\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Client.update_gridpool_order","title":"update_gridpool_order  <code>async</code>","text":"<pre><code>update_gridpool_order(\ngridpool_id: int,\norder_id: int,\nprice: Price | None | _Sentinel = NO_VALUE,\nquantity: Energy | None | _Sentinel = NO_VALUE,\nstop_price: Price | None | _Sentinel = NO_VALUE,\npeak_price_delta: Price | None | _Sentinel = NO_VALUE,\ndisplay_quantity: Energy | None | _Sentinel = NO_VALUE,\nexecution_option: OrderExecutionOption\n| None\n| _Sentinel = NO_VALUE,\nvalid_until: datetime | None | _Sentinel = NO_VALUE,\npayload: dict[str, Value] | None | _Sentinel = NO_VALUE,\ntag: str | None | _Sentinel = NO_VALUE,\n) -&gt; OrderDetail\n</code></pre> <p>Update an existing order for a given Gridpool.</p> PARAMETER  DESCRIPTION <code>gridpool_id</code> <p>ID of the Gridpool the order belongs to.</p> <p> TYPE: <code>int</code> </p> <code>order_id</code> <p>Order ID.</p> <p> TYPE: <code>int</code> </p> <code>price</code> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>quantity</code> <p>The updated quantity of the contract being traded, specified in MWh.</p> <p> TYPE: <code>Energy | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>stop_price</code> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>peak_price_delta</code> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p> <p> TYPE: <code>Price | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>display_quantity</code> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p> <p> TYPE: <code>Energy | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>execution_option</code> <p>Updated execution options such as All or None, Fill or Kill, etc.</p> <p> TYPE: <code>OrderExecutionOption | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>valid_until</code> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p> <p> TYPE: <code>datetime | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>payload</code> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p> <p> TYPE: <code>dict[str, Value] | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> <code>tag</code> <p>Updated user-defined tag to group related orders.</p> <p> TYPE: <code>str | None | _Sentinel</code> DEFAULT: <code>NO_VALUE</code> </p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>The updated order.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If no fields to update are provided.</p> Source code in <code>src/frequenz/client/electricity_trading/_client.py</code> <pre><code>async def update_gridpool_order(  # pylint: disable=too-many-arguments, too-many-locals\nself,\ngridpool_id: int,\norder_id: int,\nprice: Price | None | _Sentinel = NO_VALUE,\nquantity: Energy | None | _Sentinel = NO_VALUE,\nstop_price: Price | None | _Sentinel = NO_VALUE,\npeak_price_delta: Price | None | _Sentinel = NO_VALUE,\ndisplay_quantity: Energy | None | _Sentinel = NO_VALUE,\nexecution_option: OrderExecutionOption | None | _Sentinel = NO_VALUE,\nvalid_until: datetime | None | _Sentinel = NO_VALUE,\npayload: dict[str, struct_pb2.Value] | None | _Sentinel = NO_VALUE,\ntag: str | None | _Sentinel = NO_VALUE,\n) -&gt; OrderDetail:\n\"\"\"\n    Update an existing order for a given Gridpool.\n    Args:\n        gridpool_id: ID of the Gridpool the order belongs to.\n        order_id: Order ID.\n        price: The updated limit price at which the contract is to be traded.\n            This is the maximum price for a BUY order or the minimum price for a SELL order.\n        quantity: The updated quantity of the contract being traded, specified in MWh.\n        stop_price: Applicable for STOP_LIMIT orders. This is the updated stop price that\n            triggers the limit order.\n        peak_price_delta: Applicable for ICEBERG orders. This is the updated price difference\n            between the peak price and the limit price.\n        display_quantity: Applicable for ICEBERG orders. This is the updated quantity of the\n            order to be displayed in the order book.\n        execution_option: Updated execution options such as All or None, Fill or Kill, etc.\n        valid_until: This is an updated timestamp defining the time after which the order\n            should be cancelled if not filled. The timestamp is in UTC.\n        payload: Updated user-defined payload individual to a specific order. This can be any\n            data that the user wants to associate with the order.\n        tag: Updated user-defined tag to group related orders.\n    Returns:\n        The updated order.\n    Raises:\n        ValueError: If no fields to update are provided.\n    \"\"\"\nparams = {\n\"price\": price,\n\"quantity\": quantity,\n\"stop_price\": stop_price,\n\"peak_price_delta\": peak_price_delta,\n\"display_quantity\": display_quantity,\n\"execution_option\": execution_option,\n\"valid_until\": valid_until,\n\"payload\": payload,\n\"tag\": tag,\n}\nif all(value is NO_VALUE for value in params.values()):\nraise ValueError(\"At least one field to update must be provided.\")\npaths = [param for param, value in params.items() if value is not NO_VALUE]\n# Field mask specifying which fields should be updated\n# This is used so that we can update parameters with None values\nupdate_mask = field_mask_pb2.FieldMask(paths=paths)\nupdate_order_fields = UpdateOrder(\nprice=None if price is NO_VALUE else price,  # type: ignore\nquantity=None if quantity is NO_VALUE else quantity,  # type: ignore\nstop_price=None if stop_price is NO_VALUE else stop_price,  # type: ignore\npeak_price_delta=None\nif peak_price_delta is NO_VALUE\nelse peak_price_delta,  # type: ignore\ndisplay_quantity=None\nif display_quantity is NO_VALUE\nelse display_quantity,  # type: ignore\nexecution_option=None\nif execution_option is NO_VALUE\nelse execution_option,  # type: ignore\nvalid_until=None\nif valid_until is NO_VALUE\nelse valid_until,  # type: ignore\npayload=None if payload is NO_VALUE else payload,  # type: ignore\ntag=None if tag is NO_VALUE else tag,  # type: ignore\n)\ntry:\nresponse = await cast(\nAwaitable[electricity_trading_pb2.UpdateGridpoolOrderResponse],\nself._stub.UpdateGridpoolOrder(\nelectricity_trading_pb2.UpdateGridpoolOrderRequest(\ngridpool_id=gridpool_id,\norder_id=order_id,\nupdate_order_fields=update_order_fields.to_pb(),\nupdate_mask=update_mask,\n)\n),\n)\nreturn OrderDetail.from_pb(response.order_detail)\nexcept grpc.RpcError as e:\n_logger.exception(\"Error occurred while updating gridpool order: %s\", e)\nraise e\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency","title":"frequenz.client.electricity_trading.Currency","text":"<p>             Bases: <code>Enum</code></p> <p>List of supported currencies.</p> <p>New currencies can be added to this enum to support additional markets.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class Currency(enum.Enum):\n\"\"\"\n    List of supported currencies.\n    New currencies can be added to this enum to support additional markets.\n    \"\"\"\nUNSPECIFIED = price_pb2.Price.Currency.CURRENCY_UNSPECIFIED\n\"\"\"Currency is not specified.\"\"\"\nUSD = price_pb2.Price.Currency.CURRENCY_USD\nCAD = price_pb2.Price.Currency.CURRENCY_CAD\nEUR = price_pb2.Price.Currency.CURRENCY_EUR\nGBP = price_pb2.Price.Currency.CURRENCY_GBP\nCHF = price_pb2.Price.Currency.CURRENCY_CHF\nCNY = price_pb2.Price.Currency.CURRENCY_CNY\nJPY = price_pb2.Price.Currency.CURRENCY_JPY\nAUD = price_pb2.Price.Currency.CURRENCY_AUD\nNZD = price_pb2.Price.Currency.CURRENCY_NZD\nSGD = price_pb2.Price.Currency.CURRENCY_SGD\n@classmethod\ndef from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; \"Currency\":\n\"\"\"Convert a protobuf Currency value to Currency enum.\n        Args:\n            currency: Currency to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == currency for e in cls):\n_logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\nreturn cls.UNSPECIFIED\nreturn cls(currency)\ndef to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n\"\"\"Convert a Currency object to protobuf Currency.\n        Returns:\n            Protobuf message corresponding to the Currency object.\n        \"\"\"\nreturn price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = CURRENCY_UNSPECIFIED\n</code></pre> <p>Currency is not specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(currency: ValueType) -&gt; 'Currency'\n</code></pre> <p>Convert a protobuf Currency value to Currency enum.</p> PARAMETER  DESCRIPTION <code>currency</code> <p>Currency to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'Currency'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, currency: price_pb2.Price.Currency.ValueType) -&gt; \"Currency\":\n\"\"\"Convert a protobuf Currency value to Currency enum.\n    Args:\n        currency: Currency to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == currency for e in cls):\n_logger.warning(\"Unknown currency %s. Returning UNSPECIFIED.\", currency)\nreturn cls.UNSPECIFIED\nreturn cls(currency)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Currency.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a Currency object to protobuf Currency.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the Currency object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price.Currency.ValueType:\n\"\"\"Convert a Currency object to protobuf Currency.\n    Returns:\n        Protobuf message corresponding to the Currency object.\n    \"\"\"\nreturn price_pb2.Price.Currency.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea","title":"frequenz.client.electricity_trading.DeliveryArea  <code>dataclass</code>","text":"<p>Geographical or administrative region.</p> <p>These are, usually defined and maintained by a Transmission System Operator (TSO), where electricity deliveries for a contract occur.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass DeliveryArea:\n\"\"\"\n    Geographical or administrative region.\n    These are, usually defined and maintained by a Transmission System Operator (TSO), where\n    electricity deliveries for a contract occur.\n    \"\"\"\ncode: str\n\"\"\"Code representing the unique identifier for the delivery area.\"\"\"\ncode_type: EnergyMarketCodeType\n\"\"\"Type of code used for identifying the delivery area itself.\"\"\"\n@classmethod\ndef from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n\"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n        Args:\n            delivery_area: DeliveryArea to convert.\n        Returns:\n            DeliveryArea object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\ncode=delivery_area.code,\ncode_type=EnergyMarketCodeType.from_pb(delivery_area.code_type),\n)\ndef to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n\"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n        Returns:\n            Protobuf message corresponding to the DeliveryArea object.\n        \"\"\"\nreturn delivery_area_pb2.DeliveryArea(\ncode=self.code, code_type=self.code_type.to_pb()\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: str\n</code></pre> <p>Code representing the unique identifier for the delivery area.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.code_type","title":"code_type  <code>instance-attribute</code>","text":"<pre><code>code_type: EnergyMarketCodeType\n</code></pre> <p>Type of code used for identifying the delivery area itself.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_area: DeliveryArea) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryArea to DeliveryArea object.</p> PARAMETER  DESCRIPTION <code>delivery_area</code> <p>DeliveryArea to convert.</p> <p> TYPE: <code>DeliveryArea</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryArea object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_area: delivery_area_pb2.DeliveryArea) -&gt; Self:\n\"\"\"Convert a protobuf DeliveryArea to DeliveryArea object.\n    Args:\n        delivery_area: DeliveryArea to convert.\n    Returns:\n        DeliveryArea object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\ncode=delivery_area.code,\ncode_type=EnergyMarketCodeType.from_pb(delivery_area.code_type),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryArea.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryArea\n</code></pre> <p>Convert a DeliveryArea object to protobuf DeliveryArea.</p> RETURNS DESCRIPTION <code>DeliveryArea</code> <p>Protobuf message corresponding to the DeliveryArea object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.DeliveryArea:\n\"\"\"Convert a DeliveryArea object to protobuf DeliveryArea.\n    Returns:\n        Protobuf message corresponding to the DeliveryArea object.\n    \"\"\"\nreturn delivery_area_pb2.DeliveryArea(\ncode=self.code, code_type=self.code_type.to_pb()\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration","title":"frequenz.client.electricity_trading.DeliveryDuration","text":"<p>             Bases: <code>Enum</code></p> <p>Specifies the time increment, in minutes, used for electricity deliveries and trading.</p> <p>These durations serve as the basis for defining the delivery period in contracts, and they dictate how energy is scheduled and delivered to meet contractual obligations.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class DeliveryDuration(enum.Enum):\n\"\"\"\n    Specifies the time increment, in minutes, used for electricity deliveries and trading.\n    These durations serve as the basis for defining the delivery period in contracts, and they\n    dictate how energy is scheduled and delivered to meet contractual obligations.\n    \"\"\"\nUNSPECIFIED = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_UNSPECIFIED\n\"\"\"Default value, indicates that the duration is unspecified.\"\"\"\nMINUTES_5 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_5\n\"\"\"5-minute duration.\"\"\"\nMINUTES_15 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_15\n\"\"\"15-minute contract duration.\"\"\"\nMINUTES_30 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_30\n\"\"\"30-minute contract duration.\"\"\"\nMINUTES_60 = delivery_duration_pb2.DeliveryDuration.DELIVERY_DURATION_60\n\"\"\"1-hour contract duration.\"\"\"\n@classmethod\ndef from_pb(\ncls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n) -&gt; \"DeliveryDuration\":\n\"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n        Args:\n            delivery_duration: Delivery duration to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == delivery_duration for e in cls):\n_logger.warning(\n\"Unknown delivery duration %s. Returning UNSPECIFIED.\",\ndelivery_duration,\n)\nreturn cls.UNSPECIFIED\nreturn cls(delivery_duration)\ndef to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n\"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n        Returns:\n            Protobuf message corresponding to the DeliveryDuration object.\n        \"\"\"\nreturn delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_15","title":"MINUTES_15  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_15 = DELIVERY_DURATION_15\n</code></pre> <p>15-minute contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_30","title":"MINUTES_30  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_30 = DELIVERY_DURATION_30\n</code></pre> <p>30-minute contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_5","title":"MINUTES_5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_5 = DELIVERY_DURATION_5\n</code></pre> <p>5-minute duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.MINUTES_60","title":"MINUTES_60  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MINUTES_60 = DELIVERY_DURATION_60\n</code></pre> <p>1-hour contract duration.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = DELIVERY_DURATION_UNSPECIFIED\n</code></pre> <p>Default value, indicates that the duration is unspecified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_duration: ValueType) -&gt; 'DeliveryDuration'\n</code></pre> <p>Convert a protobuf DeliveryDuration value to DeliveryDuration enum.</p> PARAMETER  DESCRIPTION <code>delivery_duration</code> <p>Delivery duration to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'DeliveryDuration'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, delivery_duration: delivery_duration_pb2.DeliveryDuration.ValueType\n) -&gt; \"DeliveryDuration\":\n\"\"\"Convert a protobuf DeliveryDuration value to DeliveryDuration enum.\n    Args:\n        delivery_duration: Delivery duration to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == delivery_duration for e in cls):\n_logger.warning(\n\"Unknown delivery duration %s. Returning UNSPECIFIED.\",\ndelivery_duration,\n)\nreturn cls.UNSPECIFIED\nreturn cls(delivery_duration)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryDuration.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a DeliveryDuration object to protobuf DeliveryDuration.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the DeliveryDuration object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryDuration.ValueType:\n\"\"\"Convert a DeliveryDuration object to protobuf DeliveryDuration.\n    Returns:\n        Protobuf message corresponding to the DeliveryDuration object.\n    \"\"\"\nreturn delivery_duration_pb2.DeliveryDuration.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod","title":"frequenz.client.electricity_trading.DeliveryPeriod","text":"<p>Time period during which the contract is delivered.</p> <p>It is defined by a start timestamp and a duration.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class DeliveryPeriod:\n\"\"\"\n    Time period during which the contract is delivered.\n    It is defined by a start timestamp and a duration.\n    \"\"\"\nstart: datetime\n\"\"\"Start UTC timestamp represents the beginning of the delivery period.\n        This timestamp is inclusive, meaning that the delivery period starts\n        from this point in time.\"\"\"\nduration: DeliveryDuration\n\"\"\"The length of the delivery period.\"\"\"\ndef __init__(\nself,\nstart: datetime,\nduration: timedelta,\n) -&gt; None:\n\"\"\"\n        Initialize the DeliveryPeriod object.\n        Args:\n            start: Start UTC timestamp represents the beginning of the delivery period.\n            duration: The length of the delivery period.\n        Raises:\n            ValueError: If the start timestamp does not have a timezone.\n            ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n        \"\"\"\nif start.tzinfo is None:\nraise ValueError(\"Start timestamp must have a timezone.\")\nif start.tzinfo != timezone.utc:\n_logger.warning(\n\"Start timestamp is not in UTC timezone. Converting to UTC.\"\n)\nstart = start.astimezone(timezone.utc)\nself.start = start\nminutes = duration.total_seconds() / 60\nmatch minutes:\ncase 5:\nself.duration = DeliveryDuration.MINUTES_5\ncase 15:\nself.duration = DeliveryDuration.MINUTES_15\ncase 30:\nself.duration = DeliveryDuration.MINUTES_30\ncase 60:\nself.duration = DeliveryDuration.MINUTES_60\ncase _:\nraise ValueError(\n\"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n)\ndef __hash__(self) -&gt; int:\n\"\"\"\n        Create hash of the DeliveryPeriod object.\n        Returns:\n            Hash of the DeliveryPeriod object.\n        \"\"\"\nreturn hash((self.start, self.duration))\ndef __eq__(\nself,\nother: object,\n) -&gt; bool:\n\"\"\"Check if two DeliveryPeriod objects are equal.\"\"\"\nif not isinstance(other, DeliveryPeriod):\nreturn NotImplemented\nreturn self.start == other.start and self.duration == other.duration\n@classmethod\ndef from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n\"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n        Args:\n            delivery_period: DeliveryPeriod to convert.\n        Returns:\n            DeliveryPeriod object corresponding to the protobuf message.\n        Raises:\n            ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n        \"\"\"\nstart = delivery_period.start.ToDatetime(tzinfo=timezone.utc)\ndelivery_duration_enum = DeliveryDuration.from_pb(delivery_period.duration)\nmatch delivery_duration_enum:\ncase DeliveryDuration.MINUTES_5:\nduration = timedelta(minutes=5)\ncase DeliveryDuration.MINUTES_15:\nduration = timedelta(minutes=15)\ncase DeliveryDuration.MINUTES_30:\nduration = timedelta(minutes=30)\ncase DeliveryDuration.MINUTES_60:\nduration = timedelta(minutes=60)\ncase _:\nraise ValueError(\n\"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n)\nreturn cls(start=start, duration=duration)\ndef to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n\"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n        Returns:\n            Protobuf message corresponding to the DeliveryPeriod object.\n        \"\"\"\nstart = timestamp_pb2.Timestamp()\nstart.FromDatetime(self.start)\nreturn delivery_duration_pb2.DeliveryPeriod(\nstart=start,\nduration=self.duration.to_pb(),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.duration","title":"duration  <code>instance-attribute</code>","text":"<pre><code>duration: DeliveryDuration = MINUTES_60\n</code></pre> <p>The length of the delivery period.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start: datetime = start\n</code></pre> <p>Start UTC timestamp represents the beginning of the delivery period. This timestamp is inclusive, meaning that the delivery period starts from this point in time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two DeliveryPeriod objects are equal.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(\nself,\nother: object,\n) -&gt; bool:\n\"\"\"Check if two DeliveryPeriod objects are equal.\"\"\"\nif not isinstance(other, DeliveryPeriod):\nreturn NotImplemented\nreturn self.start == other.start and self.duration == other.duration\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the DeliveryPeriod object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the DeliveryPeriod object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"\n    Create hash of the DeliveryPeriod object.\n    Returns:\n        Hash of the DeliveryPeriod object.\n    \"\"\"\nreturn hash((self.start, self.duration))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.__init__","title":"__init__","text":"<pre><code>__init__(start: datetime, duration: timedelta) -&gt; None\n</code></pre> <p>Initialize the DeliveryPeriod object.</p> PARAMETER  DESCRIPTION <code>start</code> <p>Start UTC timestamp represents the beginning of the delivery period.</p> <p> TYPE: <code>datetime</code> </p> <code>duration</code> <p>The length of the delivery period.</p> <p> TYPE: <code>timedelta</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the start timestamp does not have a timezone.</p> <code>ValueError</code> <p>If the duration is not 5, 15, 30, or 60 minutes.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __init__(\nself,\nstart: datetime,\nduration: timedelta,\n) -&gt; None:\n\"\"\"\n    Initialize the DeliveryPeriod object.\n    Args:\n        start: Start UTC timestamp represents the beginning of the delivery period.\n        duration: The length of the delivery period.\n    Raises:\n        ValueError: If the start timestamp does not have a timezone.\n        ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n    \"\"\"\nif start.tzinfo is None:\nraise ValueError(\"Start timestamp must have a timezone.\")\nif start.tzinfo != timezone.utc:\n_logger.warning(\n\"Start timestamp is not in UTC timezone. Converting to UTC.\"\n)\nstart = start.astimezone(timezone.utc)\nself.start = start\nminutes = duration.total_seconds() / 60\nmatch minutes:\ncase 5:\nself.duration = DeliveryDuration.MINUTES_5\ncase 15:\nself.duration = DeliveryDuration.MINUTES_15\ncase 30:\nself.duration = DeliveryDuration.MINUTES_30\ncase 60:\nself.duration = DeliveryDuration.MINUTES_60\ncase _:\nraise ValueError(\n\"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(delivery_period: DeliveryPeriod) -&gt; Self\n</code></pre> <p>Convert a protobuf DeliveryPeriod to DeliveryPeriod object.</p> PARAMETER  DESCRIPTION <code>delivery_period</code> <p>DeliveryPeriod to convert.</p> <p> TYPE: <code>DeliveryPeriod</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>DeliveryPeriod object corresponding to the protobuf message.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the duration is not 5, 15, 30, or 60 minutes.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, delivery_period: delivery_duration_pb2.DeliveryPeriod) -&gt; Self:\n\"\"\"Convert a protobuf DeliveryPeriod to DeliveryPeriod object.\n    Args:\n        delivery_period: DeliveryPeriod to convert.\n    Returns:\n        DeliveryPeriod object corresponding to the protobuf message.\n    Raises:\n        ValueError: If the duration is not 5, 15, 30, or 60 minutes.\n    \"\"\"\nstart = delivery_period.start.ToDatetime(tzinfo=timezone.utc)\ndelivery_duration_enum = DeliveryDuration.from_pb(delivery_period.duration)\nmatch delivery_duration_enum:\ncase DeliveryDuration.MINUTES_5:\nduration = timedelta(minutes=5)\ncase DeliveryDuration.MINUTES_15:\nduration = timedelta(minutes=15)\ncase DeliveryDuration.MINUTES_30:\nduration = timedelta(minutes=30)\ncase DeliveryDuration.MINUTES_60:\nduration = timedelta(minutes=60)\ncase _:\nraise ValueError(\n\"Invalid duration value. Duration must be 5, 15, 30, or 60 minutes.\"\n)\nreturn cls(start=start, duration=duration)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.DeliveryPeriod.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; DeliveryPeriod\n</code></pre> <p>Convert a DeliveryPeriod object to protobuf DeliveryPeriod.</p> RETURNS DESCRIPTION <code>DeliveryPeriod</code> <p>Protobuf message corresponding to the DeliveryPeriod object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_duration_pb2.DeliveryPeriod:\n\"\"\"Convert a DeliveryPeriod object to protobuf DeliveryPeriod.\n    Returns:\n        Protobuf message corresponding to the DeliveryPeriod object.\n    \"\"\"\nstart = timestamp_pb2.Timestamp()\nstart.FromDatetime(self.start)\nreturn delivery_duration_pb2.DeliveryPeriod(\nstart=start,\nduration=self.duration.to_pb(),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy","title":"frequenz.client.electricity_trading.Energy  <code>dataclass</code>","text":"<p>Represents energy unit in Megawatthours (MWh).</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Energy:\n\"\"\"Represents energy unit in Megawatthours (MWh).\"\"\"\nmwh: Decimal\n@classmethod\ndef from_pb(cls, energy: energy_pb2.Energy) -&gt; Self:\n\"\"\"Convert a protobuf Energy to Energy object.\n        Args:\n            energy: Energy to convert.\n        Returns:\n            Energy object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(mwh=Decimal(energy.mwh.value))\ndef to_pb(self) -&gt; energy_pb2.Energy:\n\"\"\"Convert a Energy object to protobuf Energy.\n        Returns:\n            Protobuf message corresponding to the Energy object.\n        \"\"\"\ndecimal_mwh = decimal_pb2.Decimal()\ndecimal_mwh.value = str(self.mwh)\nreturn energy_pb2.Energy(mwh=decimal_mwh)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(energy: Energy) -&gt; Self\n</code></pre> <p>Convert a protobuf Energy to Energy object.</p> PARAMETER  DESCRIPTION <code>energy</code> <p>Energy to convert.</p> <p> TYPE: <code>Energy</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Energy object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, energy: energy_pb2.Energy) -&gt; Self:\n\"\"\"Convert a protobuf Energy to Energy object.\n    Args:\n        energy: Energy to convert.\n    Returns:\n        Energy object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(mwh=Decimal(energy.mwh.value))\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Energy.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Energy\n</code></pre> <p>Convert a Energy object to protobuf Energy.</p> RETURNS DESCRIPTION <code>Energy</code> <p>Protobuf message corresponding to the Energy object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; energy_pb2.Energy:\n\"\"\"Convert a Energy object to protobuf Energy.\n    Returns:\n        Protobuf message corresponding to the Energy object.\n    \"\"\"\ndecimal_mwh = decimal_pb2.Decimal()\ndecimal_mwh.value = str(self.mwh)\nreturn energy_pb2.Energy(mwh=decimal_mwh)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType","title":"frequenz.client.electricity_trading.EnergyMarketCodeType","text":"<p>             Bases: <code>Enum</code></p> <p>Specifies the type of identification code used in the energy market.</p> <p>This is used for uniquely identifying various entities such as delivery areas, market participants, and grid components. This enumeration aims to offer compatibility across different jurisdictional standards.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class EnergyMarketCodeType(enum.Enum):\n\"\"\"\n    Specifies the type of identification code used in the energy market.\n    This is used for uniquely identifying various entities such as delivery areas, market\n    participants, and grid components. This enumeration aims to offer compatibility across\n    different jurisdictional standards.\n    \"\"\"\nUNSPECIFIED = (\ndelivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n)\n\"\"\"Unspecified type. This value is a placeholder and should not be used.\"\"\"\nEUROPE_EIC = (\ndelivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n)\n\"\"\"European Energy Identification Code Standard.\"\"\"\nUS_NERC = delivery_area_pb2.EnergyMarketCodeType.ENERGY_MARKET_CODE_TYPE_US_NERC\n\"\"\"North American Electric Reliability Corporation identifiers.\"\"\"\n@classmethod\ndef from_pb(\ncls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n) -&gt; \"EnergyMarketCodeType\":\n\"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n        Args:\n            energy_market_code_type: Energy market code type to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == energy_market_code_type for e in cls):\n_logger.warning(\n\"Unknown energy market code type %s. Returning UNSPECIFIED.\",\nenergy_market_code_type,\n)\nreturn cls.UNSPECIFIED\nreturn cls(energy_market_code_type)\ndef to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n\"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n        Returns:\n            Protobuf message corresponding to the EnergyMarketCodeType object.\n        \"\"\"\nreturn delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.EUROPE_EIC","title":"EUROPE_EIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EUROPE_EIC = ENERGY_MARKET_CODE_TYPE_EUROPE_EIC\n</code></pre> <p>European Energy Identification Code Standard.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ENERGY_MARKET_CODE_TYPE_UNSPECIFIED\n</code></pre> <p>Unspecified type. This value is a placeholder and should not be used.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.US_NERC","title":"US_NERC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>US_NERC = ENERGY_MARKET_CODE_TYPE_US_NERC\n</code></pre> <p>North American Electric Reliability Corporation identifiers.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\nenergy_market_code_type: ValueType,\n) -&gt; \"EnergyMarketCodeType\"\n</code></pre> <p>Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.</p> PARAMETER  DESCRIPTION <code>energy_market_code_type</code> <p>Energy market code type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'EnergyMarketCodeType'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, energy_market_code_type: delivery_area_pb2.EnergyMarketCodeType.ValueType\n) -&gt; \"EnergyMarketCodeType\":\n\"\"\"Convert a protobuf EnergyMarketCodeType value to EnergyMarketCodeType enum.\n    Args:\n        energy_market_code_type: Energy market code type to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == energy_market_code_type for e in cls):\n_logger.warning(\n\"Unknown energy market code type %s. Returning UNSPECIFIED.\",\nenergy_market_code_type,\n)\nreturn cls.UNSPECIFIED\nreturn cls(energy_market_code_type)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.EnergyMarketCodeType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the EnergyMarketCodeType object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; delivery_area_pb2.EnergyMarketCodeType.ValueType:\n\"\"\"Convert a EnergyMarketCodeType object to protobuf EnergyMarketCodeType.\n    Returns:\n        Protobuf message corresponding to the EnergyMarketCodeType object.\n    \"\"\"\nreturn delivery_area_pb2.EnergyMarketCodeType.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter","title":"frequenz.client.electricity_trading.GridpoolOrderFilter  <code>dataclass</code>","text":"<p>Parameters for filtering Gridpool orders.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass GridpoolOrderFilter:\n\"\"\"Parameters for filtering Gridpool orders.\"\"\"\norder_states: list[OrderState] | None = None\n\"\"\"List of order states to filter for.\"\"\"\nside: MarketSide | None = None\n\"\"\"Market side to filter for.\"\"\"\ndelivery_period: DeliveryPeriod | None = None\n\"\"\"Delivery period to filter for.\"\"\"\ndelivery_area: DeliveryArea | None = None\n\"\"\"Delivery area to filter for.\"\"\"\ntag: str | None = None\n\"\"\"Tag associated with the orders to be filtered.\"\"\"\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        Check if two GridpoolOrderFilter objects are equal.\n        Args:\n            other: GridpoolOrderFilter object to compare with.\n        Returns:\n            True if the two GridpoolOrderFilter objects are equal, False otherwise.\n        \"\"\"\nif not isinstance(other, GridpoolOrderFilter):\nreturn NotImplemented\nreturn (\nself.order_states == other.order_states\nand self.side == other.side\nand self.delivery_period == other.delivery_period\nand self.delivery_area == other.delivery_area\nand self.tag == other.tag\n)\ndef __hash__(self) -&gt; int:\n\"\"\"\n        Create hash of the GridpoolOrderFilter object.\n        Returns:\n            Hash of the GridpoolOrderFilter object.\n        \"\"\"\nreturn hash(\n(\ntuple(self.order_states) if self.order_states is not None else None,\nself.side,\nself.delivery_period,\nself.delivery_area,\nself.tag,\n)\n)\n@classmethod\ndef from_pb(\ncls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n) -&gt; Self:\n\"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n        Args:\n            gridpool_order_filter: GridpoolOrderFilter to convert.\n        Returns:\n            GridpoolOrderFilter object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\norder_states=[\nOrderState.from_pb(state) for state in gridpool_order_filter.states\n],\nside=MarketSide.from_pb(gridpool_order_filter.side),\ndelivery_period=DeliveryPeriod.from_pb(\ngridpool_order_filter.delivery_period\n),\ndelivery_area=DeliveryArea.from_pb(gridpool_order_filter.delivery_area),\ntag=gridpool_order_filter.tag,\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n\"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n        Returns:\n            Protobuf GridpoolOrderFilter corresponding to the object.\n        \"\"\"\nreturn electricity_trading_pb2.GridpoolOrderFilter(\nstates=[\nelectricity_trading_pb2.OrderState.ValueType(state.value)\nfor state in self.order_states\n]\nif self.order_states\nelse None,\nside=electricity_trading_pb2.MarketSide.ValueType(self.side.value)\nif self.side\nelse None,\ndelivery_period=self.delivery_period.to_pb()\nif self.delivery_period\nelse None,\ndelivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\ntag=self.tag if self.tag else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_area","title":"delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.order_states","title":"order_states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>order_states: list[OrderState] | None = None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: MarketSide | None = None\n</code></pre> <p>Market side to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>Tag associated with the orders to be filtered.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two GridpoolOrderFilter objects are equal.</p> PARAMETER  DESCRIPTION <code>other</code> <p>GridpoolOrderFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two GridpoolOrderFilter objects are equal, False otherwise.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    Check if two GridpoolOrderFilter objects are equal.\n    Args:\n        other: GridpoolOrderFilter object to compare with.\n    Returns:\n        True if the two GridpoolOrderFilter objects are equal, False otherwise.\n    \"\"\"\nif not isinstance(other, GridpoolOrderFilter):\nreturn NotImplemented\nreturn (\nself.order_states == other.order_states\nand self.side == other.side\nand self.delivery_period == other.delivery_period\nand self.delivery_area == other.delivery_area\nand self.tag == other.tag\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the GridpoolOrderFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the GridpoolOrderFilter object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"\n    Create hash of the GridpoolOrderFilter object.\n    Returns:\n        Hash of the GridpoolOrderFilter object.\n    \"\"\"\nreturn hash(\n(\ntuple(self.order_states) if self.order_states is not None else None,\nself.side,\nself.delivery_period,\nself.delivery_area,\nself.tag,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(gridpool_order_filter: GridpoolOrderFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.</p> PARAMETER  DESCRIPTION <code>gridpool_order_filter</code> <p>GridpoolOrderFilter to convert.</p> <p> TYPE: <code>GridpoolOrderFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>GridpoolOrderFilter object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, gridpool_order_filter: electricity_trading_pb2.GridpoolOrderFilter\n) -&gt; Self:\n\"\"\"Convert a protobuf GridpoolOrderFilter to GridpoolOrderFilter object.\n    Args:\n        gridpool_order_filter: GridpoolOrderFilter to convert.\n    Returns:\n        GridpoolOrderFilter object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\norder_states=[\nOrderState.from_pb(state) for state in gridpool_order_filter.states\n],\nside=MarketSide.from_pb(gridpool_order_filter.side),\ndelivery_period=DeliveryPeriod.from_pb(\ngridpool_order_filter.delivery_period\n),\ndelivery_area=DeliveryArea.from_pb(gridpool_order_filter.delivery_area),\ntag=gridpool_order_filter.tag,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolOrderFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; GridpoolOrderFilter\n</code></pre> <p>Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.</p> RETURNS DESCRIPTION <code>GridpoolOrderFilter</code> <p>Protobuf GridpoolOrderFilter corresponding to the object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.GridpoolOrderFilter:\n\"\"\"Convert a GridpoolOrderFilter object to protobuf GridpoolOrderFilter.\n    Returns:\n        Protobuf GridpoolOrderFilter corresponding to the object.\n    \"\"\"\nreturn electricity_trading_pb2.GridpoolOrderFilter(\nstates=[\nelectricity_trading_pb2.OrderState.ValueType(state.value)\nfor state in self.order_states\n]\nif self.order_states\nelse None,\nside=electricity_trading_pb2.MarketSide.ValueType(self.side.value)\nif self.side\nelse None,\ndelivery_period=self.delivery_period.to_pb()\nif self.delivery_period\nelse None,\ndelivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\ntag=self.tag if self.tag else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter","title":"frequenz.client.electricity_trading.GridpoolTradeFilter  <code>dataclass</code>","text":"<p>Parameters for filtering Gridpool trades.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass GridpoolTradeFilter:\n\"\"\"Parameters for filtering Gridpool trades.\"\"\"\ntrade_states: list[TradeState] | None = None\n\"\"\"List of trade states to filter for.\"\"\"\ntrade_ids: list[int] | None = None\n\"\"\"List of trade ids to filter for.\"\"\"\nside: MarketSide | None = None\n\"\"\"Market side to filter for.\"\"\"\ndelivery_period: DeliveryPeriod | None = None\n\"\"\"Delivery period to filter for.\"\"\"\ndelivery_area: DeliveryArea | None = None\n\"\"\"Delivery area to filter for.\"\"\"\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        Check if two GridpoolTradeFilter objects are equal.\n        Args:\n            other: GridpoolTradeFilter object to compare with.\n        Returns:\n            True if the two GridpoolTradeFilter objects are equal, False otherwise.\n        \"\"\"\nif not isinstance(other, GridpoolTradeFilter):\nreturn NotImplemented\nreturn (\nself.trade_states == other.trade_states\nand self.trade_ids == other.trade_ids\nand self.side == other.side\nand self.delivery_period == other.delivery_period\nand self.delivery_area == other.delivery_area\n)\ndef __hash__(self) -&gt; int:\n\"\"\"\n        Create hash of the GridpoolTradeFilter object.\n        Returns:\n            Hash of the GridpoolTradeFilter object.\n        \"\"\"\nreturn hash(\n(\ntuple(self.trade_states) if self.trade_states is not None else None,\ntuple(self.trade_ids) if self.trade_ids is not None else None,\nself.side,\nself.delivery_period,\nself.delivery_area,\n)\n)\n@classmethod\ndef from_pb(\ncls, gridpool_trade_filter: electricity_trading_pb2.GridpoolTradeFilter\n) -&gt; \"GridpoolTradeFilter\":\n\"\"\"Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.\n        Args:\n            gridpool_trade_filter: GridpoolTradeFilter to convert.\n        Returns:\n            GridpoolTradeFilter object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\ntrade_states=[\nTradeState.from_pb(state) for state in gridpool_trade_filter.states\n],\ntrade_ids=list(gridpool_trade_filter.trade_ids),\nside=MarketSide.from_pb(gridpool_trade_filter.side),\ndelivery_period=DeliveryPeriod.from_pb(\ngridpool_trade_filter.delivery_period\n),\ndelivery_area=DeliveryArea.from_pb(gridpool_trade_filter.delivery_area),\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.GridpoolTradeFilter:\n\"\"\"\n        Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.\n        Returns:\n            Protobuf GridpoolTradeFilter corresponding to the object.\n        \"\"\"\nreturn electricity_trading_pb2.GridpoolTradeFilter(\nstates=[TradeState.to_pb(state) for state in self.trade_states]\nif self.trade_states\nelse None,\ntrade_ids=self.trade_ids if self.trade_ids else None,\nside=MarketSide.to_pb(self.side) if self.side else None,\ndelivery_period=self.delivery_period.to_pb()\nif self.delivery_period\nelse None,\ndelivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.delivery_area","title":"delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.side","title":"side  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>side: MarketSide | None = None\n</code></pre> <p>Market side to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.trade_ids","title":"trade_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade_ids: list[int] | None = None\n</code></pre> <p>List of trade ids to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.trade_states","title":"trade_states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>trade_states: list[TradeState] | None = None\n</code></pre> <p>List of trade states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two GridpoolTradeFilter objects are equal.</p> PARAMETER  DESCRIPTION <code>other</code> <p>GridpoolTradeFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two GridpoolTradeFilter objects are equal, False otherwise.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    Check if two GridpoolTradeFilter objects are equal.\n    Args:\n        other: GridpoolTradeFilter object to compare with.\n    Returns:\n        True if the two GridpoolTradeFilter objects are equal, False otherwise.\n    \"\"\"\nif not isinstance(other, GridpoolTradeFilter):\nreturn NotImplemented\nreturn (\nself.trade_states == other.trade_states\nand self.trade_ids == other.trade_ids\nand self.side == other.side\nand self.delivery_period == other.delivery_period\nand self.delivery_area == other.delivery_area\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the GridpoolTradeFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the GridpoolTradeFilter object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"\n    Create hash of the GridpoolTradeFilter object.\n    Returns:\n        Hash of the GridpoolTradeFilter object.\n    \"\"\"\nreturn hash(\n(\ntuple(self.trade_states) if self.trade_states is not None else None,\ntuple(self.trade_ids) if self.trade_ids is not None else None,\nself.side,\nself.delivery_period,\nself.delivery_area,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\ngridpool_trade_filter: GridpoolTradeFilter,\n) -&gt; \"GridpoolTradeFilter\"\n</code></pre> <p>Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.</p> PARAMETER  DESCRIPTION <code>gridpool_trade_filter</code> <p>GridpoolTradeFilter to convert.</p> <p> TYPE: <code>GridpoolTradeFilter</code> </p> RETURNS DESCRIPTION <code>'GridpoolTradeFilter'</code> <p>GridpoolTradeFilter object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, gridpool_trade_filter: electricity_trading_pb2.GridpoolTradeFilter\n) -&gt; \"GridpoolTradeFilter\":\n\"\"\"Convert a protobuf GridpoolTradeFilter to GridpoolTradeFilter object.\n    Args:\n        gridpool_trade_filter: GridpoolTradeFilter to convert.\n    Returns:\n        GridpoolTradeFilter object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\ntrade_states=[\nTradeState.from_pb(state) for state in gridpool_trade_filter.states\n],\ntrade_ids=list(gridpool_trade_filter.trade_ids),\nside=MarketSide.from_pb(gridpool_trade_filter.side),\ndelivery_period=DeliveryPeriod.from_pb(\ngridpool_trade_filter.delivery_period\n),\ndelivery_area=DeliveryArea.from_pb(gridpool_trade_filter.delivery_area),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.GridpoolTradeFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; GridpoolTradeFilter\n</code></pre> <p>Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.</p> RETURNS DESCRIPTION <code>GridpoolTradeFilter</code> <p>Protobuf GridpoolTradeFilter corresponding to the object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.GridpoolTradeFilter:\n\"\"\"\n    Convert a GridpoolTradeFilter object to protobuf GridpoolTradeFilter.\n    Returns:\n        Protobuf GridpoolTradeFilter corresponding to the object.\n    \"\"\"\nreturn electricity_trading_pb2.GridpoolTradeFilter(\nstates=[TradeState.to_pb(state) for state in self.trade_states]\nif self.trade_states\nelse None,\ntrade_ids=self.trade_ids if self.trade_ids else None,\nside=MarketSide.to_pb(self.side) if self.side else None,\ndelivery_period=self.delivery_period.to_pb()\nif self.delivery_period\nelse None,\ndelivery_area=self.delivery_area.to_pb() if self.delivery_area else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor","title":"frequenz.client.electricity_trading.MarketActor","text":"<p>             Bases: <code>Enum</code></p> <p>Actors responsible for an order state change.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class MarketActor(enum.Enum):\n\"\"\"Actors responsible for an order state change.\"\"\"\nUNSPECIFIED = (\nelectricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_UNSPECIFIED\n)\n\"\"\"The actor responsible for the state change has not been specified.\"\"\"\nUSER = electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_USER\n\"\"\"The user was the actor.\"\"\"\nMARKET_OPERATOR = (\nelectricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_MARKET_OPERATOR\n)\n\"\"\"The market operator was the actor.\"\"\"\nSYSTEM = (\nelectricity_trading_pb2.OrderDetail.StateDetail.MarketActor.MARKET_ACTOR_SYSTEM\n)\n\"\"\"The system was the actor.\"\"\"\n@classmethod\ndef from_pb(\ncls,\nmarket_actor: electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType,\n) -&gt; \"MarketActor\":\n\"\"\"Convert a protobuf MarketActor value to MarketActor enum.\n        Args:\n            market_actor: Market actor to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == market_actor for e in cls):\n_logger.warning(\n\"Unknown market actor %s. Returning UNSPECIFIED.\", market_actor\n)\nreturn cls.UNSPECIFIED\nreturn cls(market_actor)\ndef to_pb(\nself,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType:\n\"\"\"Convert a MarketActor enum to protobuf MarketActor value.\n        Returns:\n            Protobuf message corresponding to the MarketActor enum.\n        \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.MARKET_OPERATOR","title":"MARKET_OPERATOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MARKET_OPERATOR = MARKET_ACTOR_MARKET_OPERATOR\n</code></pre> <p>The market operator was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.SYSTEM","title":"SYSTEM  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SYSTEM = MARKET_ACTOR_SYSTEM\n</code></pre> <p>The system was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = MARKET_ACTOR_UNSPECIFIED\n</code></pre> <p>The actor responsible for the state change has not been specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.USER","title":"USER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>USER = MARKET_ACTOR_USER\n</code></pre> <p>The user was the actor.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(market_actor: ValueType) -&gt; 'MarketActor'\n</code></pre> <p>Convert a protobuf MarketActor value to MarketActor enum.</p> PARAMETER  DESCRIPTION <code>market_actor</code> <p>Market actor to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'MarketActor'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls,\nmarket_actor: electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType,\n) -&gt; \"MarketActor\":\n\"\"\"Convert a protobuf MarketActor value to MarketActor enum.\n    Args:\n        market_actor: Market actor to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == market_actor for e in cls):\n_logger.warning(\n\"Unknown market actor %s. Returning UNSPECIFIED.\", market_actor\n)\nreturn cls.UNSPECIFIED\nreturn cls(market_actor)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketActor.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a MarketActor enum to protobuf MarketActor value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the MarketActor enum.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(\nself,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType:\n\"\"\"Convert a MarketActor enum to protobuf MarketActor value.\n    Returns:\n        Protobuf message corresponding to the MarketActor enum.\n    \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide","title":"frequenz.client.electricity_trading.MarketSide","text":"<p>             Bases: <code>Enum</code></p> <p>Which side of the market the order is on, either buying or selling.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class MarketSide(enum.Enum):\n\"\"\"Which side of the market the order is on, either buying or selling.\"\"\"\nUNSPECIFIED = electricity_trading_pb2.MarketSide.MARKET_SIDE_UNSPECIFIED\n\"\"\"The side of the market has not been set.\"\"\"\nBUY = electricity_trading_pb2.MarketSide.MARKET_SIDE_BUY\n\"\"\"Order to purchase electricity, referred to as a 'bid' in the order book.\"\"\"\nSELL = electricity_trading_pb2.MarketSide.MARKET_SIDE_SELL\n\"\"\"Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.\"\"\"\n@classmethod\ndef from_pb(\ncls, market_side: electricity_trading_pb2.MarketSide.ValueType\n) -&gt; \"MarketSide\":\n\"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n        Args:\n            market_side: Market side to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == market_side for e in cls):\n_logger.warning(\n\"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n)\nreturn cls.UNSPECIFIED\nreturn cls(market_side)\ndef to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n\"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n        Returns:\n            Protobuf message corresponding to the MarketSide enum.\n        \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.BUY","title":"BUY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUY = MARKET_SIDE_BUY\n</code></pre> <p>Order to purchase electricity, referred to as a 'bid' in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.SELL","title":"SELL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>SELL = MARKET_SIDE_SELL\n</code></pre> <p>Order to sell electricity, referred to as an 'ask' or 'offer' in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = MARKET_SIDE_UNSPECIFIED\n</code></pre> <p>The side of the market has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(market_side: ValueType) -&gt; 'MarketSide'\n</code></pre> <p>Convert a protobuf MarketSide value to MarketSide enum.</p> PARAMETER  DESCRIPTION <code>market_side</code> <p>Market side to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'MarketSide'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, market_side: electricity_trading_pb2.MarketSide.ValueType\n) -&gt; \"MarketSide\":\n\"\"\"Convert a protobuf MarketSide value to MarketSide enum.\n    Args:\n        market_side: Market side to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == market_side for e in cls):\n_logger.warning(\n\"Unknown market side %s. Returning UNSPECIFIED.\", market_side\n)\nreturn cls.UNSPECIFIED\nreturn cls(market_side)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.MarketSide.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a MarketSide enum to protobuf MarketSide value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the MarketSide enum.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.MarketSide.ValueType:\n\"\"\"Convert a MarketSide enum to protobuf MarketSide value.\n    Returns:\n        Protobuf message corresponding to the MarketSide enum.\n    \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order","title":"frequenz.client.electricity_trading.Order  <code>dataclass</code>","text":"<p>Represents an order in the electricity market.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass Order:  # pylint: disable=too-many-instance-attributes\n\"\"\"Represents an order in the electricity market.\"\"\"\ndelivery_area: DeliveryArea\n\"\"\"The delivery area where the contract is to be delivered.\"\"\"\ndelivery_period: DeliveryPeriod\n\"\"\"The delivery period for the contract.\"\"\"\ntype: OrderType\n\"\"\"The type of order.\"\"\"\nside: MarketSide\n\"\"\"Indicates if the order is on the Buy or Sell side of the market.\"\"\"\nprice: Price\n\"\"\"The limit price at which the contract is to be traded.\"\"\"\nquantity: Energy\n\"\"\"The quantity of the contract being traded.\"\"\"\nstop_price: Price | None = None\n\"\"\"Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.\"\"\"\npeak_price_delta: Price | None = None\n\"\"\"Applicable for ICEBERG orders. The price difference between the peak price and\n    the limit price.\"\"\"\ndisplay_quantity: Energy | None = None\n\"\"\"Applicable for ICEBERG orders. The quantity of the order to be displayed in the order\n    book.\"\"\"\nexecution_option: OrderExecutionOption | None = None\n\"\"\"Order execution options such as All or None, Fill or Kill, etc.\"\"\"\nvalid_until: datetime | None = None\n\"\"\"UTC timestamp defining the time after which the order should be cancelled if not filled.\"\"\"\npayload: dict[str, struct_pb2.Value] | None = None\n\"\"\"User-defined payload individual to a specific order. This can be any data that needs to be\n    associated with the order.\"\"\"\ntag: str | None = None\n\"\"\"User-defined tag to group related orders.\"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.valid_until is not None:\nif self.valid_until.tzinfo is None:\nraise ValueError(\"Valid until must be a UTC datetime.\")\nif self.valid_until.tzinfo != timezone.utc:\n_logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\nself.valid_until = self.valid_until.astimezone(timezone.utc)\n@classmethod\ndef from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n\"\"\"Convert a protobuf Order to Order object.\n        Args:\n            order: Order to convert.\n        Returns:\n            Order object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\ndelivery_area=DeliveryArea.from_pb(order.delivery_area),\ndelivery_period=DeliveryPeriod.from_pb(order.delivery_period),\ntype=OrderType.from_pb(order.type),\nside=MarketSide.from_pb(order.side),\nprice=Price.from_pb(order.price),\nquantity=Energy.from_pb(order.quantity),\nstop_price=Price.from_pb(order.stop_price)\nif order.HasField(\"stop_price\")\nelse None,\npeak_price_delta=Price.from_pb(order.peak_price_delta)\nif order.HasField(\"peak_price_delta\")\nelse None,\ndisplay_quantity=Energy.from_pb(order.display_quantity)\nif order.HasField(\"display_quantity\")\nelse None,\nexecution_option=OrderExecutionOption.from_pb(order.execution_option)\nif order.HasField(\"execution_option\")\nelse None,\nvalid_until=order.valid_until.ToDatetime(tzinfo=timezone.utc)\nif order.HasField(\"valid_until\")\nelse None,\npayload=json_format.MessageToDict(order.payload) if order.payload else None,\ntag=order.tag if order.tag else None,\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.Order:\n\"\"\"\n        Convert an Order object to protobuf Order.\n        Returns:\n            Protobuf message corresponding to the Order object.\n        \"\"\"\nif self.valid_until:\nvalid_until = timestamp_pb2.Timestamp()\nvalid_until.FromDatetime(self.valid_until)\nelse:\nvalid_until = None\nreturn electricity_trading_pb2.Order(\ndelivery_area=self.delivery_area.to_pb(),\ndelivery_period=self.delivery_period.to_pb(),\ntype=electricity_trading_pb2.OrderType.ValueType(self.type.value),\nside=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\nprice=self.price.to_pb(),\nquantity=self.quantity.to_pb(),\nstop_price=self.stop_price.to_pb() if self.stop_price else None,\npeak_price_delta=self.peak_price_delta.to_pb()\nif self.peak_price_delta\nelse None,\ndisplay_quantity=self.display_quantity.to_pb()\nif self.display_quantity\nelse None,\nexecution_option=(\nelectricity_trading_pb2.OrderExecutionOption.ValueType(\nself.execution_option.value\n)\nif self.execution_option\nelse None\n),\nvalid_until=valid_until,\npayload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\ntag=self.tag if self.tag else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>The delivery area where the contract is to be delivered.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.display_quantity","title":"display_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_quantity: Energy | None = None\n</code></pre> <p>Applicable for ICEBERG orders. The quantity of the order to be displayed in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.execution_option","title":"execution_option  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None = None\n</code></pre> <p>Order execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.payload","title":"payload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None = None\n</code></pre> <p>User-defined payload individual to a specific order. This can be any data that needs to be associated with the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.peak_price_delta","title":"peak_price_delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None = None\n</code></pre> <p>Applicable for ICEBERG orders. The price difference between the peak price and the limit price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide\n</code></pre> <p>Indicates if the order is on the Buy or Sell side of the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.stop_price","title":"stop_price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None = None\n</code></pre> <p>Applicable for STOP_LIMIT orders. The stop price that triggers the limit order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>User-defined tag to group related orders.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: OrderType\n</code></pre> <p>The type of order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.valid_until","title":"valid_until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None = None\n</code></pre> <p>UTC timestamp defining the time after which the order should be cancelled if not filled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.valid_until is not None:\nif self.valid_until.tzinfo is None:\nraise ValueError(\"Valid until must be a UTC datetime.\")\nif self.valid_until.tzinfo != timezone.utc:\n_logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\nself.valid_until = self.valid_until.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order: Order) -&gt; Self\n</code></pre> <p>Convert a protobuf Order to Order object.</p> PARAMETER  DESCRIPTION <code>order</code> <p>Order to convert.</p> <p> TYPE: <code>Order</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Order object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order: electricity_trading_pb2.Order) -&gt; Self:\n\"\"\"Convert a protobuf Order to Order object.\n    Args:\n        order: Order to convert.\n    Returns:\n        Order object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\ndelivery_area=DeliveryArea.from_pb(order.delivery_area),\ndelivery_period=DeliveryPeriod.from_pb(order.delivery_period),\ntype=OrderType.from_pb(order.type),\nside=MarketSide.from_pb(order.side),\nprice=Price.from_pb(order.price),\nquantity=Energy.from_pb(order.quantity),\nstop_price=Price.from_pb(order.stop_price)\nif order.HasField(\"stop_price\")\nelse None,\npeak_price_delta=Price.from_pb(order.peak_price_delta)\nif order.HasField(\"peak_price_delta\")\nelse None,\ndisplay_quantity=Energy.from_pb(order.display_quantity)\nif order.HasField(\"display_quantity\")\nelse None,\nexecution_option=OrderExecutionOption.from_pb(order.execution_option)\nif order.HasField(\"execution_option\")\nelse None,\nvalid_until=order.valid_until.ToDatetime(tzinfo=timezone.utc)\nif order.HasField(\"valid_until\")\nelse None,\npayload=json_format.MessageToDict(order.payload) if order.payload else None,\ntag=order.tag if order.tag else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Order.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Order\n</code></pre> <p>Convert an Order object to protobuf Order.</p> RETURNS DESCRIPTION <code>Order</code> <p>Protobuf message corresponding to the Order object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.Order:\n\"\"\"\n    Convert an Order object to protobuf Order.\n    Returns:\n        Protobuf message corresponding to the Order object.\n    \"\"\"\nif self.valid_until:\nvalid_until = timestamp_pb2.Timestamp()\nvalid_until.FromDatetime(self.valid_until)\nelse:\nvalid_until = None\nreturn electricity_trading_pb2.Order(\ndelivery_area=self.delivery_area.to_pb(),\ndelivery_period=self.delivery_period.to_pb(),\ntype=electricity_trading_pb2.OrderType.ValueType(self.type.value),\nside=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\nprice=self.price.to_pb(),\nquantity=self.quantity.to_pb(),\nstop_price=self.stop_price.to_pb() if self.stop_price else None,\npeak_price_delta=self.peak_price_delta.to_pb()\nif self.peak_price_delta\nelse None,\ndisplay_quantity=self.display_quantity.to_pb()\nif self.display_quantity\nelse None,\nexecution_option=(\nelectricity_trading_pb2.OrderExecutionOption.ValueType(\nself.execution_option.value\n)\nif self.execution_option\nelse None\n),\nvalid_until=valid_until,\npayload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\ntag=self.tag if self.tag else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail","title":"frequenz.client.electricity_trading.OrderDetail  <code>dataclass</code>","text":"<p>Represents an order with full details, including its ID, state, and associated UTC timestamps.</p> ATTRIBUTE DESCRIPTION <code>order_id</code> <p>Unique identifier of the order.</p> <p> TYPE: <code>int</code> </p> <code>order</code> <p>The details of the order.</p> <p> TYPE: <code>Order</code> </p> <code>state_detail</code> <p>Details of the order's current state.</p> <p> TYPE: <code>StateDetail</code> </p> <code>open_quantity</code> <p>Remaining open quantity for this order.</p> <p> TYPE: <code>Energy</code> </p> <code>filled_quantity</code> <p>Filled quantity for this order.</p> <p> TYPE: <code>Energy</code> </p> <code>create_time</code> <p>UTC Timestamp when the order was created.</p> <p> TYPE: <code>datetime</code> </p> <code>modification_time</code> <p>UTC Timestamp of the last update to the order.</p> <p> TYPE: <code>datetime</code> </p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass OrderDetail:\n\"\"\"\n    Represents an order with full details, including its ID, state, and associated UTC timestamps.\n    Attributes:\n        order_id: Unique identifier of the order.\n        order: The details of the order.\n        state_detail: Details of the order's current state.\n        open_quantity: Remaining open quantity for this order.\n        filled_quantity: Filled quantity for this order.\n        create_time: UTC Timestamp when the order was created.\n        modification_time: UTC Timestamp of the last update to the order.\n    \"\"\"\norder_id: int\norder: Order\nstate_detail: StateDetail\nopen_quantity: Energy\nfilled_quantity: Energy\ncreate_time: datetime\nmodification_time: datetime\ndef __post_init__(self) -&gt; None:\n\"\"\"\n        Post initialization checks to ensure that all datetimes are UTC.\n        Raises:\n            ValueError: If create_time or modification_time do not have timezone information.\n        \"\"\"\nif self.create_time.tzinfo is None:\nraise ValueError(\"Create time must have timezone information\")\nif self.create_time.tzinfo != timezone.utc:\n_logger.warning(\"Create time is not in UTC timezone. Converting to UTC.\")\nself.create_time = self.create_time.astimezone(timezone.utc)\nif self.modification_time.tzinfo is None:\nraise ValueError(\"Modification time must have timezone information\")\nif self.modification_time.tzinfo != timezone.utc:\n_logger.warning(\n\"Modification time is not in UTC timezone. Converting to UTC.\"\n)\nself.modification_time = self.modification_time.astimezone(timezone.utc)\n@classmethod\ndef from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n\"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n        Args:\n            order_detail: OrderDetail to convert.\n        Returns:\n            OrderDetail object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\norder_id=order_detail.order_id,\norder=Order.from_pb(order_detail.order),\nstate_detail=StateDetail.from_pb(order_detail.state_detail),\nopen_quantity=Energy.from_pb(order_detail.open_quantity),\nfilled_quantity=Energy.from_pb(order_detail.filled_quantity),\ncreate_time=order_detail.create_time.ToDatetime(tzinfo=timezone.utc),\nmodification_time=order_detail.modification_time.ToDatetime(\ntzinfo=timezone.utc\n),\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.OrderDetail:\n\"\"\"Convert an OrderDetail object to protobuf OrderDetail.\n        Returns:\n            Protobuf message corresponding to the OrderDetail object.\n        \"\"\"\ncreate_time = timestamp_pb2.Timestamp()\ncreate_time.FromDatetime(self.create_time)\nmodification_time = timestamp_pb2.Timestamp()\nmodification_time.FromDatetime(self.modification_time)\nreturn electricity_trading_pb2.OrderDetail(\norder_id=self.order_id,\norder=self.order.to_pb(),\nstate_detail=self.state_detail.to_pb(),\nopen_quantity=self.open_quantity.to_pb(),\nfilled_quantity=self.filled_quantity.to_pb(),\ncreate_time=create_time,\nmodification_time=modification_time,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If create_time or modification_time do not have timezone information.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"\n    Post initialization checks to ensure that all datetimes are UTC.\n    Raises:\n        ValueError: If create_time or modification_time do not have timezone information.\n    \"\"\"\nif self.create_time.tzinfo is None:\nraise ValueError(\"Create time must have timezone information\")\nif self.create_time.tzinfo != timezone.utc:\n_logger.warning(\"Create time is not in UTC timezone. Converting to UTC.\")\nself.create_time = self.create_time.astimezone(timezone.utc)\nif self.modification_time.tzinfo is None:\nraise ValueError(\"Modification time must have timezone information\")\nif self.modification_time.tzinfo != timezone.utc:\n_logger.warning(\n\"Modification time is not in UTC timezone. Converting to UTC.\"\n)\nself.modification_time = self.modification_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_detail: OrderDetail) -&gt; Self\n</code></pre> <p>Convert a protobuf OrderDetail to OrderDetail object.</p> PARAMETER  DESCRIPTION <code>order_detail</code> <p>OrderDetail to convert.</p> <p> TYPE: <code>OrderDetail</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>OrderDetail object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, order_detail: electricity_trading_pb2.OrderDetail) -&gt; Self:\n\"\"\"Convert a protobuf OrderDetail to OrderDetail object.\n    Args:\n        order_detail: OrderDetail to convert.\n    Returns:\n        OrderDetail object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\norder_id=order_detail.order_id,\norder=Order.from_pb(order_detail.order),\nstate_detail=StateDetail.from_pb(order_detail.state_detail),\nopen_quantity=Energy.from_pb(order_detail.open_quantity),\nfilled_quantity=Energy.from_pb(order_detail.filled_quantity),\ncreate_time=order_detail.create_time.ToDatetime(tzinfo=timezone.utc),\nmodification_time=order_detail.modification_time.ToDatetime(\ntzinfo=timezone.utc\n),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderDetail.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; OrderDetail\n</code></pre> <p>Convert an OrderDetail object to protobuf OrderDetail.</p> RETURNS DESCRIPTION <code>OrderDetail</code> <p>Protobuf message corresponding to the OrderDetail object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail:\n\"\"\"Convert an OrderDetail object to protobuf OrderDetail.\n    Returns:\n        Protobuf message corresponding to the OrderDetail object.\n    \"\"\"\ncreate_time = timestamp_pb2.Timestamp()\ncreate_time.FromDatetime(self.create_time)\nmodification_time = timestamp_pb2.Timestamp()\nmodification_time.FromDatetime(self.modification_time)\nreturn electricity_trading_pb2.OrderDetail(\norder_id=self.order_id,\norder=self.order.to_pb(),\nstate_detail=self.state_detail.to_pb(),\nopen_quantity=self.open_quantity.to_pb(),\nfilled_quantity=self.filled_quantity.to_pb(),\ncreate_time=create_time,\nmodification_time=modification_time,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption","title":"frequenz.client.electricity_trading.OrderExecutionOption","text":"<p>             Bases: <code>Enum</code></p> <p>Specific behavior for the execution of an order.</p> <p>These options provide control on how an order is handled in the market.</p> <p>If no OrderExecutionOption is set, the order remains open until it's fully fulfilled, cancelled by the client, <code>valid_until</code> timestamp is reached, or the end of the trading session.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderExecutionOption(enum.Enum):\n\"\"\"\n    Specific behavior for the execution of an order.\n    These options provide control on how an order is handled in the market.\n    If no OrderExecutionOption is set, the order remains open until it's fully\n    fulfilled, cancelled by the client, `valid_until` timestamp is reached, or\n    the end of the trading session.\n    \"\"\"\nUNSPECIFIED = (\nelectricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_UNSPECIFIED\n)\n\"\"\"The order execution option has not been set.\"\"\"\nAON = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_AON\n\"\"\"All or None: Order must be executed in its entirety, or not executed at all.\"\"\"\nFOK = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_FOK\n\"\"\"Fill or Kill: Order must be executed immediately in its entirety, or not at all.\"\"\"\nIOC = electricity_trading_pb2.OrderExecutionOption.ORDER_EXECUTION_OPTION_IOC\n\"\"\"Immediate or Cancel: Any portion of an order that cannot be filled \\\n    immediately will be cancelled.\"\"\"\n@classmethod\ndef from_pb(\ncls,\norder_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n) -&gt; \"OrderExecutionOption\":\n\"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n        Args:\n            order_execution_option: order execution option to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == order_execution_option for e in OrderExecutionOption):\n_logger.warning(\n\"Unknown forecast feature %s. Returning UNSPECIFIED.\",\norder_execution_option,\n)\nreturn cls.UNSPECIFIED\nreturn OrderExecutionOption(order_execution_option)\ndef to_pb(self) -&gt; electricity_trading_pb2.OrderExecutionOption.ValueType:\n\"\"\"Convert a OrderExecutionOption object to protobuf OrderExecutionOption.\n        Returns:\n            Protobuf message corresponding to the OrderExecutionOption object.\n        \"\"\"\nreturn electricity_trading_pb2.OrderExecutionOption.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.AON","title":"AON  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>AON = ORDER_EXECUTION_OPTION_AON\n</code></pre> <p>All or None: Order must be executed in its entirety, or not executed at all.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.FOK","title":"FOK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FOK = ORDER_EXECUTION_OPTION_FOK\n</code></pre> <p>Fill or Kill: Order must be executed immediately in its entirety, or not at all.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.IOC","title":"IOC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>IOC = ORDER_EXECUTION_OPTION_IOC\n</code></pre> <p>Immediate or Cancel: Any portion of an order that cannot be filled     immediately will be cancelled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_EXECUTION_OPTION_UNSPECIFIED\n</code></pre> <p>The order execution option has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(\norder_execution_option: ValueType,\n) -&gt; \"OrderExecutionOption\"\n</code></pre> <p>Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.</p> PARAMETER  DESCRIPTION <code>order_execution_option</code> <p>order execution option to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderExecutionOption'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls,\norder_execution_option: electricity_trading_pb2.OrderExecutionOption.ValueType,\n) -&gt; \"OrderExecutionOption\":\n\"\"\"Convert a protobuf OrderExecutionOption value to OrderExecutionOption enum.\n    Args:\n        order_execution_option: order execution option to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == order_execution_option for e in OrderExecutionOption):\n_logger.warning(\n\"Unknown forecast feature %s. Returning UNSPECIFIED.\",\norder_execution_option,\n)\nreturn cls.UNSPECIFIED\nreturn OrderExecutionOption(order_execution_option)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderExecutionOption.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a OrderExecutionOption object to protobuf OrderExecutionOption.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderExecutionOption object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderExecutionOption.ValueType:\n\"\"\"Convert a OrderExecutionOption object to protobuf OrderExecutionOption.\n    Returns:\n        Protobuf message corresponding to the OrderExecutionOption object.\n    \"\"\"\nreturn electricity_trading_pb2.OrderExecutionOption.ValueType(self.value)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState","title":"frequenz.client.electricity_trading.OrderState","text":"<p>             Bases: <code>Enum</code></p> <p>State of an order.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderState(enum.Enum):\n\"\"\"State of an order.\"\"\"\nUNSPECIFIED = electricity_trading_pb2.OrderState.ORDER_STATE_UNSPECIFIED\n\"\"\"The order state is not known. Usually the default state of a newly created order object\n    before any operations have been applied.\"\"\"\nPENDING = electricity_trading_pb2.OrderState.ORDER_STATE_PENDING\n\"\"\"The order has been sent to the marketplace but has not yet been confirmed. This can be due\n    to awaiting validation or system processing.\"\"\"\nACTIVE = electricity_trading_pb2.OrderState.ORDER_STATE_ACTIVE\n\"\"\"The order has been confirmed and is open in the market. It may be unfilled or partially\n    filled.\"\"\"\nFILLED = electricity_trading_pb2.OrderState.ORDER_STATE_FILLED\n\"\"\"The order has been completely filled and there are no remaining quantities on the order.\"\"\"\nCANCELED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCELED\n\"\"\"The order has been canceled. This can occur due to a cancellation request by the market\n    participant, system, or market operator.\"\"\"\nCANCEL_REQUESTED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCEL_REQUESTED\n\"\"\"A cancellation request for the order has been submitted but the order is not yet removed\n    from the order book.\"\"\"\nCANCEL_REJECTED = electricity_trading_pb2.OrderState.ORDER_STATE_CANCEL_REJECTED\n\"\"\"The order cancellation request was rejected, likely due to it having already been filled or\n    expired.\"\"\"\nEXPIRED = electricity_trading_pb2.OrderState.ORDER_STATE_EXPIRED\n\"\"\"The order has not been filled within the defined duration and has expired.\"\"\"\nFAILED = electricity_trading_pb2.OrderState.ORDER_STATE_FAILED\n\"\"\"The order submission failed and was unable to be placed on the order book, usually due to a\n    validation error or system issue.\"\"\"\nHIBERNATE = electricity_trading_pb2.OrderState.ORDER_STATE_HIBERNATE\n\"\"\"The order has been entered into the system but is not currently exposed to the market. This\n    could be due to certain conditions not yet being met.\"\"\"\n@classmethod\ndef from_pb(\ncls, order_state: electricity_trading_pb2.OrderState.ValueType\n) -&gt; \"OrderState\":\n\"\"\"Convert a protobuf OrderState value to OrderState enum.\n        Args:\n            order_state: Order state to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == order_state for e in cls):\n_logger.warning(\n\"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n)\nreturn cls.UNSPECIFIED\nreturn cls(order_state)\ndef to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n\"\"\"Convert an OrderState enum to protobuf OrderState value.\n        Returns:\n            Protobuf message corresponding to the OrderState enum.\n        \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = ORDER_STATE_ACTIVE\n</code></pre> <p>The order has been confirmed and is open in the market. It may be unfilled or partially filled.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCELED","title":"CANCELED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELED = ORDER_STATE_CANCELED\n</code></pre> <p>The order has been canceled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCEL_REJECTED","title":"CANCEL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REJECTED = ORDER_STATE_CANCEL_REJECTED\n</code></pre> <p>The order cancellation request was rejected, likely due to it having already been filled or expired.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.CANCEL_REQUESTED","title":"CANCEL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REQUESTED = ORDER_STATE_CANCEL_REQUESTED\n</code></pre> <p>A cancellation request for the order has been submitted but the order is not yet removed from the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.EXPIRED","title":"EXPIRED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>EXPIRED = ORDER_STATE_EXPIRED\n</code></pre> <p>The order has not been filled within the defined duration and has expired.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FAILED","title":"FAILED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FAILED = ORDER_STATE_FAILED\n</code></pre> <p>The order submission failed and was unable to be placed on the order book, usually due to a validation error or system issue.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.FILLED","title":"FILLED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FILLED = ORDER_STATE_FILLED\n</code></pre> <p>The order has been completely filled and there are no remaining quantities on the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.HIBERNATE","title":"HIBERNATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HIBERNATE = ORDER_STATE_HIBERNATE\n</code></pre> <p>The order has been entered into the system but is not currently exposed to the market. This could be due to certain conditions not yet being met.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.PENDING","title":"PENDING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PENDING = ORDER_STATE_PENDING\n</code></pre> <p>The order has been sent to the marketplace but has not yet been confirmed. This can be due to awaiting validation or system processing.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_STATE_UNSPECIFIED\n</code></pre> <p>The order state is not known. Usually the default state of a newly created order object before any operations have been applied.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_state: ValueType) -&gt; 'OrderState'\n</code></pre> <p>Convert a protobuf OrderState value to OrderState enum.</p> PARAMETER  DESCRIPTION <code>order_state</code> <p>Order state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderState'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, order_state: electricity_trading_pb2.OrderState.ValueType\n) -&gt; \"OrderState\":\n\"\"\"Convert a protobuf OrderState value to OrderState enum.\n    Args:\n        order_state: Order state to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == order_state for e in cls):\n_logger.warning(\n\"Unknown order state %s. Returning UNSPECIFIED.\", order_state\n)\nreturn cls.UNSPECIFIED\nreturn cls(order_state)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderState.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderState enum to protobuf OrderState value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderState enum.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderState.ValueType:\n\"\"\"Convert an OrderState enum to protobuf OrderState value.\n    Returns:\n        Protobuf message corresponding to the OrderState enum.\n    \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType","title":"frequenz.client.electricity_trading.OrderType","text":"<p>             Bases: <code>Enum</code></p> <p>Type of the order (specifies how the order is to be executed in the market).</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class OrderType(enum.Enum):\n\"\"\"Type of the order (specifies how the order is to be executed in the market).\"\"\"\nUNSPECIFIED = electricity_trading_pb2.OrderType.ORDER_TYPE_UNSPECIFIED\n\"\"\"The order type has not been set.\"\"\"\nLIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_LIMIT\n\"\"\"Order to buy or sell at a specific price or better.\n    It remains active until it is filled, cancelled, or expired.\"\"\"\nSTOP_LIMIT = electricity_trading_pb2.OrderType.ORDER_TYPE_STOP_LIMIT\n\"\"\"An order that will be executed at a specified price,\n    or better, after a given stop price has been reached.\"\"\"\nICEBERG = electricity_trading_pb2.OrderType.ORDER_TYPE_ICEBERG\n\"\"\"A large order divided into smaller lots to hide the actual order quantity.\n    Only the visible part of the order is shown in the order book.\"\"\"\nBLOCK = electricity_trading_pb2.OrderType.ORDER_TYPE_BLOCK\n\"\"\"User defined block order, generally a large quantity order filled all at once.\n    (Not yet supported).\"\"\"\nBALANCE = electricity_trading_pb2.OrderType.ORDER_TYPE_BALANCE\n\"\"\"Balance order aims to balance supply and demand, usually at\n    a specific location or within a system.(Not yet supported).\"\"\"\nPREARRANGED = electricity_trading_pb2.OrderType.ORDER_TYPE_PREARRANGED\n\"\"\"On exchange prearranged trade, a trade that has been privately\n    negotiated and then submitted to the exchange. (Not yet supported).\"\"\"\nPRIVATE = electricity_trading_pb2.OrderType.ORDER_TYPE_PRIVATE\n\"\"\"Private and confidential trade, not visible in the public\n    order book and has no market impact. (Not yet supported).\"\"\"\n@classmethod\ndef from_pb(\ncls, order_type: electricity_trading_pb2.OrderType.ValueType\n) -&gt; \"OrderType\":\n\"\"\"Convert a protobuf OrderType value to OrderType enum.\n        Args:\n            order_type: Order type to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == order_type for e in cls):\n_logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\nreturn cls.UNSPECIFIED\nreturn cls(order_type)\ndef to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n\"\"\"Convert an OrderType enum to protobuf OrderType value.\n        Returns:\n            Protobuf message corresponding to the OrderType enum.\n        \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BALANCE","title":"BALANCE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BALANCE = ORDER_TYPE_BALANCE\n</code></pre> <p>Balance order aims to balance supply and demand, usually at a specific location or within a system.(Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.BLOCK","title":"BLOCK  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BLOCK = ORDER_TYPE_BLOCK\n</code></pre> <p>User defined block order, generally a large quantity order filled all at once. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.ICEBERG","title":"ICEBERG  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICEBERG = ORDER_TYPE_ICEBERG\n</code></pre> <p>A large order divided into smaller lots to hide the actual order quantity. Only the visible part of the order is shown in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.LIMIT","title":"LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIMIT = ORDER_TYPE_LIMIT\n</code></pre> <p>Order to buy or sell at a specific price or better. It remains active until it is filled, cancelled, or expired.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PREARRANGED","title":"PREARRANGED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PREARRANGED = ORDER_TYPE_PREARRANGED\n</code></pre> <p>On exchange prearranged trade, a trade that has been privately negotiated and then submitted to the exchange. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.PRIVATE","title":"PRIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PRIVATE = ORDER_TYPE_PRIVATE\n</code></pre> <p>Private and confidential trade, not visible in the public order book and has no market impact. (Not yet supported).</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.STOP_LIMIT","title":"STOP_LIMIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOP_LIMIT = ORDER_TYPE_STOP_LIMIT\n</code></pre> <p>An order that will be executed at a specified price, or better, after a given stop price has been reached.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = ORDER_TYPE_UNSPECIFIED\n</code></pre> <p>The order type has not been set.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(order_type: ValueType) -&gt; 'OrderType'\n</code></pre> <p>Convert a protobuf OrderType value to OrderType enum.</p> PARAMETER  DESCRIPTION <code>order_type</code> <p>Order type to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'OrderType'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, order_type: electricity_trading_pb2.OrderType.ValueType\n) -&gt; \"OrderType\":\n\"\"\"Convert a protobuf OrderType value to OrderType enum.\n    Args:\n        order_type: Order type to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == order_type for e in cls):\n_logger.warning(\"Unknown order type %s. Returning UNSPECIFIED.\", order_type)\nreturn cls.UNSPECIFIED\nreturn cls(order_type)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.OrderType.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert an OrderType enum to protobuf OrderType value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the OrderType enum.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderType.ValueType:\n\"\"\"Convert an OrderType enum to protobuf OrderType value.\n    Returns:\n        Protobuf message corresponding to the OrderType enum.\n    \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams","title":"frequenz.client.electricity_trading.PaginationParams  <code>dataclass</code>","text":"<p>Parameters for paginating list requests.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PaginationParams:\n\"\"\"Parameters for paginating list requests.\"\"\"\npage_size: int | None = None\n\"\"\"The maximum number of results to be returned per request.\"\"\"\npage_token: str | None = None\n\"\"\"The token identifying a specific page of the list results.\"\"\"\n@classmethod\ndef from_pb(cls, pagination_params: pagination_params_pb2.PaginationParams) -&gt; Self:\n\"\"\"Convert a protobuf PaginationParams to PaginationParams object.\n        Args:\n            pagination_params: PaginationParams to convert.\n        Returns:\n            PaginationParams object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\npage_size=pagination_params.page_size,\npage_token=pagination_params.page_token,\n)\ndef to_pb(self) -&gt; pagination_params_pb2.PaginationParams:\n\"\"\"Convert a PaginationParams object to protobuf PaginationParams.\n        Returns:\n            Protobuf message corresponding to the PaginationParams object.\n        \"\"\"\nreturn pagination_params_pb2.PaginationParams(\npage_size=self.page_size,\npage_token=self.page_token,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.page_size","title":"page_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_size: int | None = None\n</code></pre> <p>The maximum number of results to be returned per request.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.page_token","title":"page_token  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>page_token: str | None = None\n</code></pre> <p>The token identifying a specific page of the list results.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(pagination_params: PaginationParams) -&gt; Self\n</code></pre> <p>Convert a protobuf PaginationParams to PaginationParams object.</p> PARAMETER  DESCRIPTION <code>pagination_params</code> <p>PaginationParams to convert.</p> <p> TYPE: <code>PaginationParams</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PaginationParams object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, pagination_params: pagination_params_pb2.PaginationParams) -&gt; Self:\n\"\"\"Convert a protobuf PaginationParams to PaginationParams object.\n    Args:\n        pagination_params: PaginationParams to convert.\n    Returns:\n        PaginationParams object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\npage_size=pagination_params.page_size,\npage_token=pagination_params.page_token,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PaginationParams.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PaginationParams\n</code></pre> <p>Convert a PaginationParams object to protobuf PaginationParams.</p> RETURNS DESCRIPTION <code>PaginationParams</code> <p>Protobuf message corresponding to the PaginationParams object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; pagination_params_pb2.PaginationParams:\n\"\"\"Convert a PaginationParams object to protobuf PaginationParams.\n    Returns:\n        Protobuf message corresponding to the PaginationParams object.\n    \"\"\"\nreturn pagination_params_pb2.PaginationParams(\npage_size=self.page_size,\npage_token=self.page_token,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price","title":"frequenz.client.electricity_trading.Price  <code>dataclass</code>","text":"<p>Price of an order.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass Price:\n\"\"\"Price of an order.\"\"\"\namount: Decimal\n\"\"\"Amount of the price.\"\"\"\ncurrency: Currency\n\"\"\"Currency of the price.\"\"\"\n@classmethod\ndef from_pb(cls, price: price_pb2.Price) -&gt; Self:\n\"\"\"Convert a protobuf Price to Price object.\n        Args:\n            price: Price to convert.\n        Returns:\n            Price object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\namount=Decimal(price.amount.value),\ncurrency=Currency.from_pb(price.currency),\n)\ndef to_pb(self) -&gt; price_pb2.Price:\n\"\"\"Convert a Price object to protobuf Price.\n        Returns:\n            Protobuf message corresponding to the Price object.\n        \"\"\"\ndecimal_amount = decimal_pb2.Decimal()\ndecimal_amount.value = str(self.amount)\nreturn price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.amount","title":"amount  <code>instance-attribute</code>","text":"<pre><code>amount: Decimal\n</code></pre> <p>Amount of the price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.currency","title":"currency  <code>instance-attribute</code>","text":"<pre><code>currency: Currency\n</code></pre> <p>Currency of the price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(price: Price) -&gt; Self\n</code></pre> <p>Convert a protobuf Price to Price object.</p> PARAMETER  DESCRIPTION <code>price</code> <p>Price to convert.</p> <p> TYPE: <code>Price</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Price object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, price: price_pb2.Price) -&gt; Self:\n\"\"\"Convert a protobuf Price to Price object.\n    Args:\n        price: Price to convert.\n    Returns:\n        Price object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\namount=Decimal(price.amount.value),\ncurrency=Currency.from_pb(price.currency),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Price.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Price\n</code></pre> <p>Convert a Price object to protobuf Price.</p> RETURNS DESCRIPTION <code>Price</code> <p>Protobuf message corresponding to the Price object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; price_pb2.Price:\n\"\"\"Convert a Price object to protobuf Price.\n    Returns:\n        Protobuf message corresponding to the Price object.\n    \"\"\"\ndecimal_amount = decimal_pb2.Decimal()\ndecimal_amount.value = str(self.amount)\nreturn price_pb2.Price(amount=decimal_amount, currency=self.currency.to_pb())\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade","title":"frequenz.client.electricity_trading.PublicTrade  <code>dataclass</code>","text":"<p>Represents a public order in the market.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass PublicTrade:  # pylint: disable=too-many-instance-attributes\n\"\"\"Represents a public order in the market.\"\"\"\npublic_trade_id: int\n\"\"\"ID of the order from the public order book.\"\"\"\nbuy_delivery_area: DeliveryArea\n\"\"\"Delivery area code of the buy side.\"\"\"\nsell_delivery_area: DeliveryArea\n\"\"\"Delivery area code of the sell side.\"\"\"\ndelivery_period: DeliveryPeriod\n\"\"\"The delivery period for the contract.\"\"\"\nexecution_time: datetime\n\"\"\"UTC Timestamp of the trades execution time.\"\"\"\nprice: Price\n\"\"\"The limit price at which the contract is to be traded.\"\"\"\nquantity: Energy\n\"\"\"The quantity of the contract being traded.\"\"\"\nstate: TradeState\n\"\"\"State of the order.\"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.execution_time.tzinfo is None:\nraise ValueError(\"Execution time must have timezone information\")\nif self.execution_time.tzinfo != timezone.utc:\n_logger.warning(\"Execution time is not in UTC timezone. Converting to UTC.\")\nself.execution_time = self.execution_time.astimezone(timezone.utc)\n@classmethod\ndef from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n\"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n        Args:\n            public_trade: PublicTrade to convert.\n        Returns:\n            PublicTrade object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\npublic_trade_id=public_trade.id,\nbuy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\nsell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\ndelivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\nexecution_time=public_trade.execution_time.ToDatetime(tzinfo=timezone.utc),\nprice=Price.from_pb(public_trade.price),\nquantity=Energy.from_pb(public_trade.quantity),\nstate=TradeState.from_pb(public_trade.state),\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.PublicTrade:\n\"\"\"Convert a PublicTrade object to protobuf PublicTrade.\n        Returns:\n            Protobuf message corresponding to the PublicTrade object.\n        \"\"\"\nexecution_time = timestamp_pb2.Timestamp()\nexecution_time.FromDatetime(self.execution_time)\nreturn electricity_trading_pb2.PublicTrade(\nid=self.public_trade_id,\nbuy_delivery_area=self.buy_delivery_area.to_pb(),\nsell_delivery_area=self.sell_delivery_area.to_pb(),\ndelivery_period=self.delivery_period.to_pb(),\nexecution_time=execution_time,\nprice=self.price.to_pb(),\nquantity=self.quantity.to_pb(),\nstate=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.buy_delivery_area","title":"buy_delivery_area  <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the buy side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.execution_time","title":"execution_time  <code>instance-attribute</code>","text":"<pre><code>execution_time: datetime\n</code></pre> <p>UTC Timestamp of the trades execution time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The limit price at which the contract is to be traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.public_trade_id","title":"public_trade_id  <code>instance-attribute</code>","text":"<pre><code>public_trade_id: int\n</code></pre> <p>ID of the order from the public order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The quantity of the contract being traded.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.sell_delivery_area","title":"sell_delivery_area  <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea\n</code></pre> <p>Delivery area code of the sell side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: TradeState\n</code></pre> <p>State of the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.execution_time.tzinfo is None:\nraise ValueError(\"Execution time must have timezone information\")\nif self.execution_time.tzinfo != timezone.utc:\n_logger.warning(\"Execution time is not in UTC timezone. Converting to UTC.\")\nself.execution_time = self.execution_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade: PublicTrade) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTrade to PublicTrade object.</p> PARAMETER  DESCRIPTION <code>public_trade</code> <p>PublicTrade to convert.</p> <p> TYPE: <code>PublicTrade</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTrade object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, public_trade: electricity_trading_pb2.PublicTrade) -&gt; Self:\n\"\"\"Convert a protobuf PublicTrade to PublicTrade object.\n    Args:\n        public_trade: PublicTrade to convert.\n    Returns:\n        PublicTrade object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\npublic_trade_id=public_trade.id,\nbuy_delivery_area=DeliveryArea.from_pb(public_trade.buy_delivery_area),\nsell_delivery_area=DeliveryArea.from_pb(public_trade.sell_delivery_area),\ndelivery_period=DeliveryPeriod.from_pb(public_trade.delivery_period),\nexecution_time=public_trade.execution_time.ToDatetime(tzinfo=timezone.utc),\nprice=Price.from_pb(public_trade.price),\nquantity=Energy.from_pb(public_trade.quantity),\nstate=TradeState.from_pb(public_trade.state),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTrade.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PublicTrade\n</code></pre> <p>Convert a PublicTrade object to protobuf PublicTrade.</p> RETURNS DESCRIPTION <code>PublicTrade</code> <p>Protobuf message corresponding to the PublicTrade object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.PublicTrade:\n\"\"\"Convert a PublicTrade object to protobuf PublicTrade.\n    Returns:\n        Protobuf message corresponding to the PublicTrade object.\n    \"\"\"\nexecution_time = timestamp_pb2.Timestamp()\nexecution_time.FromDatetime(self.execution_time)\nreturn electricity_trading_pb2.PublicTrade(\nid=self.public_trade_id,\nbuy_delivery_area=self.buy_delivery_area.to_pb(),\nsell_delivery_area=self.sell_delivery_area.to_pb(),\ndelivery_period=self.delivery_period.to_pb(),\nexecution_time=execution_time,\nprice=self.price.to_pb(),\nquantity=self.quantity.to_pb(),\nstate=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter","title":"frequenz.client.electricity_trading.PublicTradeFilter  <code>dataclass</code>","text":"<p>Parameters for filtering the historic, publicly executed orders (trades).</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass PublicTradeFilter:\n\"\"\"Parameters for filtering the historic, publicly executed orders (trades).\"\"\"\nstates: list[TradeState] | None = None\n\"\"\"List of order states to filter for.\"\"\"\ndelivery_period: DeliveryPeriod | None = None\n\"\"\"Delivery period to filter for.\"\"\"\nbuy_delivery_area: DeliveryArea | None = None\n\"\"\"Delivery area to filter for on the buy side.\"\"\"\nsell_delivery_area: DeliveryArea | None = None\n\"\"\"Delivery area to filter for on the sell side.\"\"\"\ndef __eq__(self, other: object) -&gt; bool:\n\"\"\"\n        Check if two PublicTradeFilter objects are equal.\n        Args:\n            other: PublicTradeFilter object to compare with.\n        Returns:\n            True if the two PublicTradeFilter objects are equal, False otherwise.\n        \"\"\"\nif not isinstance(other, PublicTradeFilter):\nreturn NotImplemented\nreturn (\nself.states == other.states\nand self.delivery_period == other.delivery_period\nand self.buy_delivery_area == other.buy_delivery_area\nand self.sell_delivery_area == other.sell_delivery_area\n)\ndef __hash__(self) -&gt; int:\n\"\"\"\n        Create hash of the PublicTradeFilter object.\n        Returns:\n            Hash of the PublicTradeFilter object.\n        \"\"\"\nreturn hash(\n(\ntuple(self.states) if self.states is not None else None,\nself.delivery_period,\nself.buy_delivery_area,\nself.sell_delivery_area,\n)\n)\n@classmethod\ndef from_pb(\ncls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n) -&gt; Self:\n\"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n        Args:\n            public_trade_filter: PublicTradeFilter to convert.\n        Returns:\n            PublicTradeFilter object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\nstates=[TradeState.from_pb(state) for state in public_trade_filter.states],\ndelivery_period=DeliveryPeriod.from_pb(public_trade_filter.delivery_period),\nbuy_delivery_area=DeliveryArea.from_pb(\npublic_trade_filter.buy_delivery_area\n),\nsell_delivery_area=DeliveryArea.from_pb(\npublic_trade_filter.sell_delivery_area\n),\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n\"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n        Returns:\n            Protobuf PublicTradeFilter corresponding to the object.\n        \"\"\"\nreturn electricity_trading_pb2.PublicTradeFilter(\nstates=[\nelectricity_trading_pb2.TradeState.ValueType(state.value)\nfor state in self.states\n]\nif self.states\nelse None,\ndelivery_period=self.delivery_period.to_pb()\nif self.delivery_period\nelse None,\nbuy_delivery_area=self.buy_delivery_area.to_pb()\nif self.buy_delivery_area\nelse None,\nsell_delivery_area=self.sell_delivery_area.to_pb()\nif self.sell_delivery_area\nelse None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.buy_delivery_area","title":"buy_delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>buy_delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for on the buy side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.delivery_period","title":"delivery_period  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod | None = None\n</code></pre> <p>Delivery period to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.sell_delivery_area","title":"sell_delivery_area  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sell_delivery_area: DeliveryArea | None = None\n</code></pre> <p>Delivery area to filter for on the sell side.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.states","title":"states  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>states: list[TradeState] | None = None\n</code></pre> <p>List of order states to filter for.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.__eq__","title":"__eq__","text":"<pre><code>__eq__(other: object) -&gt; bool\n</code></pre> <p>Check if two PublicTradeFilter objects are equal.</p> PARAMETER  DESCRIPTION <code>other</code> <p>PublicTradeFilter object to compare with.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the two PublicTradeFilter objects are equal, False otherwise.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n\"\"\"\n    Check if two PublicTradeFilter objects are equal.\n    Args:\n        other: PublicTradeFilter object to compare with.\n    Returns:\n        True if the two PublicTradeFilter objects are equal, False otherwise.\n    \"\"\"\nif not isinstance(other, PublicTradeFilter):\nreturn NotImplemented\nreturn (\nself.states == other.states\nand self.delivery_period == other.delivery_period\nand self.buy_delivery_area == other.buy_delivery_area\nand self.sell_delivery_area == other.sell_delivery_area\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Create hash of the PublicTradeFilter object.</p> RETURNS DESCRIPTION <code>int</code> <p>Hash of the PublicTradeFilter object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __hash__(self) -&gt; int:\n\"\"\"\n    Create hash of the PublicTradeFilter object.\n    Returns:\n        Hash of the PublicTradeFilter object.\n    \"\"\"\nreturn hash(\n(\ntuple(self.states) if self.states is not None else None,\nself.delivery_period,\nself.buy_delivery_area,\nself.sell_delivery_area,\n)\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(public_trade_filter: PublicTradeFilter) -&gt; Self\n</code></pre> <p>Convert a protobuf PublicTradeFilter to PublicTradeFilter object.</p> PARAMETER  DESCRIPTION <code>public_trade_filter</code> <p>PublicTradeFilter to convert.</p> <p> TYPE: <code>PublicTradeFilter</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>PublicTradeFilter object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, public_trade_filter: electricity_trading_pb2.PublicTradeFilter\n) -&gt; Self:\n\"\"\"Convert a protobuf PublicTradeFilter to PublicTradeFilter object.\n    Args:\n        public_trade_filter: PublicTradeFilter to convert.\n    Returns:\n        PublicTradeFilter object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\nstates=[TradeState.from_pb(state) for state in public_trade_filter.states],\ndelivery_period=DeliveryPeriod.from_pb(public_trade_filter.delivery_period),\nbuy_delivery_area=DeliveryArea.from_pb(\npublic_trade_filter.buy_delivery_area\n),\nsell_delivery_area=DeliveryArea.from_pb(\npublic_trade_filter.sell_delivery_area\n),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.PublicTradeFilter.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; PublicTradeFilter\n</code></pre> <p>Convert a PublicTradeFilter object to protobuf PublicTradeFilter.</p> RETURNS DESCRIPTION <code>PublicTradeFilter</code> <p>Protobuf PublicTradeFilter corresponding to the object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.PublicTradeFilter:\n\"\"\"Convert a PublicTradeFilter object to protobuf PublicTradeFilter.\n    Returns:\n        Protobuf PublicTradeFilter corresponding to the object.\n    \"\"\"\nreturn electricity_trading_pb2.PublicTradeFilter(\nstates=[\nelectricity_trading_pb2.TradeState.ValueType(state.value)\nfor state in self.states\n]\nif self.states\nelse None,\ndelivery_period=self.delivery_period.to_pb()\nif self.delivery_period\nelse None,\nbuy_delivery_area=self.buy_delivery_area.to_pb()\nif self.buy_delivery_area\nelse None,\nsell_delivery_area=self.sell_delivery_area.to_pb()\nif self.sell_delivery_area\nelse None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail","title":"frequenz.client.electricity_trading.StateDetail  <code>dataclass</code>","text":"<p>Details about the current state of the order.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass(frozen=True)\nclass StateDetail:\n\"\"\"Details about the current state of the order.\"\"\"\nstate: OrderState\n\"\"\"Current state of the order.\"\"\"\nstate_reason: StateReason\n\"\"\"Reason for the current state.\"\"\"\nmarket_actor: MarketActor\n\"\"\"Actor responsible for the current state.\"\"\"\n@classmethod\ndef from_pb(\ncls, state_detail: electricity_trading_pb2.OrderDetail.StateDetail\n) -&gt; Self:\n\"\"\"Convert a protobuf StateDetail to StateDetail object.\n        Args:\n            state_detail: StateDetail to convert.\n        Returns:\n            StateDetail object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\nstate=OrderState.from_pb(state_detail.state),\nstate_reason=StateReason.from_pb(state_detail.state_reason),\nmarket_actor=MarketActor.from_pb(state_detail.market_actor),\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.OrderDetail.StateDetail:\n\"\"\"Convert a StateDetail object to protobuf StateDetail.\n        Returns:\n            Protobuf message corresponding to the StateDetail object.\n        \"\"\"\nreturn electricity_trading_pb2.OrderDetail.StateDetail(\nstate=electricity_trading_pb2.OrderState.ValueType(self.state.value),\nstate_reason=electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType(\nself.state_reason.value\n),\nmarket_actor=electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType(\nself.market_actor.value\n),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.market_actor","title":"market_actor  <code>instance-attribute</code>","text":"<pre><code>market_actor: MarketActor\n</code></pre> <p>Actor responsible for the current state.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: OrderState\n</code></pre> <p>Current state of the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.state_reason","title":"state_reason  <code>instance-attribute</code>","text":"<pre><code>state_reason: StateReason\n</code></pre> <p>Reason for the current state.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state_detail: StateDetail) -&gt; Self\n</code></pre> <p>Convert a protobuf StateDetail to StateDetail object.</p> PARAMETER  DESCRIPTION <code>state_detail</code> <p>StateDetail to convert.</p> <p> TYPE: <code>StateDetail</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>StateDetail object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, state_detail: electricity_trading_pb2.OrderDetail.StateDetail\n) -&gt; Self:\n\"\"\"Convert a protobuf StateDetail to StateDetail object.\n    Args:\n        state_detail: StateDetail to convert.\n    Returns:\n        StateDetail object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\nstate=OrderState.from_pb(state_detail.state),\nstate_reason=StateReason.from_pb(state_detail.state_reason),\nmarket_actor=MarketActor.from_pb(state_detail.market_actor),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateDetail.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; StateDetail\n</code></pre> <p>Convert a StateDetail object to protobuf StateDetail.</p> RETURNS DESCRIPTION <code>StateDetail</code> <p>Protobuf message corresponding to the StateDetail object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.OrderDetail.StateDetail:\n\"\"\"Convert a StateDetail object to protobuf StateDetail.\n    Returns:\n        Protobuf message corresponding to the StateDetail object.\n    \"\"\"\nreturn electricity_trading_pb2.OrderDetail.StateDetail(\nstate=electricity_trading_pb2.OrderState.ValueType(self.state.value),\nstate_reason=electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType(\nself.state_reason.value\n),\nmarket_actor=electricity_trading_pb2.OrderDetail.StateDetail.MarketActor.ValueType(\nself.market_actor.value\n),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason","title":"frequenz.client.electricity_trading.StateReason","text":"<p>             Bases: <code>Enum</code></p> <p>Reason that led to a state change.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class StateReason(enum.Enum):\n\"\"\"Reason that led to a state change.\"\"\"\nUNSPECIFIED = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_UNSPECIFIED\n)\n\"\"\"The reason for the state change has not been specified.\"\"\"\nADD = electricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_ADD\n\"\"\"The order was added.\"\"\"\nMODIFY = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_MODIFY\n)\n\"\"\"The order was modified.\"\"\"\nDELETE = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_DELETE\n)\n\"\"\"The order was deleted.\"\"\"\nDEACTIVATE = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_DEACTIVATE\n)\n\"\"\"The order was deactivated.\"\"\"\nREJECT = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_REJECT\n)\n\"\"\"The order was rejected.\"\"\"\nFULL_EXECUTION = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_FULL_EXECUTION\n)\n\"\"\"The order was fully executed.\"\"\"\nPARTIAL_EXECUTION = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_PARTIAL_EXECUTION\n)\n\"\"\"The order was partially executed.\"\"\"\nICEBERG_SLICE_ADD = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_ICEBERG_SLICE_ADD\n)\n\"\"\"An iceberg slice was added.\"\"\"\nVALIDATION_FAIL = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_VALIDATION_FAIL\n)\n\"\"\"The order failed validation.\"\"\"\nUNKNOWN_STATE = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_UNKNOWN_STATE\n)\n\"\"\"The state of the order is unknown.\"\"\"\nQUOTE_ADD = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_ADD\n)\n\"\"\"A quote was added.\"\"\"\nQUOTE_FULL_EXECUTION = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_FULL_EXECUTION  # noqa: E501\n)\n\"\"\"A quote was fully executed.\"\"\"\nQUOTE_PARTIAL_EXECUTION = (\nelectricity_trading_pb2.OrderDetail.StateDetail.StateReason.STATE_REASON_QUOTE_PARTIAL_EXECUTION  # noqa: E501\n)\n\"\"\"A quote was partially executed.\"\"\"\n@classmethod\ndef from_pb(\ncls,\nstate_reason: electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType,\n) -&gt; \"StateReason\":\n\"\"\"Convert a protobuf StateReason value to StateReason enum.\n        Args:\n            state_reason: State reason to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == state_reason for e in cls):\n_logger.warning(\n\"Unknown state reason %s. Returning UNSPECIFIED.\", state_reason\n)\nreturn cls.UNSPECIFIED\nreturn cls(state_reason)\ndef to_pb(\nself,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType:\n\"\"\"Convert a StateReason enum to protobuf StateReason value.\n        Returns:\n            Protobuf message corresponding to the StateReason enum.\n        \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.ADD","title":"ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ADD = STATE_REASON_ADD\n</code></pre> <p>The order was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.DEACTIVATE","title":"DEACTIVATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DEACTIVATE = STATE_REASON_DEACTIVATE\n</code></pre> <p>The order was deactivated.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.DELETE","title":"DELETE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DELETE = STATE_REASON_DELETE\n</code></pre> <p>The order was deleted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.FULL_EXECUTION","title":"FULL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FULL_EXECUTION = STATE_REASON_FULL_EXECUTION\n</code></pre> <p>The order was fully executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.ICEBERG_SLICE_ADD","title":"ICEBERG_SLICE_ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ICEBERG_SLICE_ADD = STATE_REASON_ICEBERG_SLICE_ADD\n</code></pre> <p>An iceberg slice was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.MODIFY","title":"MODIFY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODIFY = STATE_REASON_MODIFY\n</code></pre> <p>The order was modified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.PARTIAL_EXECUTION","title":"PARTIAL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PARTIAL_EXECUTION = STATE_REASON_PARTIAL_EXECUTION\n</code></pre> <p>The order was partially executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_ADD","title":"QUOTE_ADD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_ADD = STATE_REASON_QUOTE_ADD\n</code></pre> <p>A quote was added.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_FULL_EXECUTION","title":"QUOTE_FULL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_FULL_EXECUTION = STATE_REASON_QUOTE_FULL_EXECUTION\n</code></pre> <p>A quote was fully executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.QUOTE_PARTIAL_EXECUTION","title":"QUOTE_PARTIAL_EXECUTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>QUOTE_PARTIAL_EXECUTION = (\nSTATE_REASON_QUOTE_PARTIAL_EXECUTION\n)\n</code></pre> <p>A quote was partially executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.REJECT","title":"REJECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>REJECT = STATE_REASON_REJECT\n</code></pre> <p>The order was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.UNKNOWN_STATE","title":"UNKNOWN_STATE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNKNOWN_STATE = STATE_REASON_UNKNOWN_STATE\n</code></pre> <p>The state of the order is unknown.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = STATE_REASON_UNSPECIFIED\n</code></pre> <p>The reason for the state change has not been specified.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.VALIDATION_FAIL","title":"VALIDATION_FAIL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>VALIDATION_FAIL = STATE_REASON_VALIDATION_FAIL\n</code></pre> <p>The order failed validation.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(state_reason: ValueType) -&gt; 'StateReason'\n</code></pre> <p>Convert a protobuf StateReason value to StateReason enum.</p> PARAMETER  DESCRIPTION <code>state_reason</code> <p>State reason to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'StateReason'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls,\nstate_reason: electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType,\n) -&gt; \"StateReason\":\n\"\"\"Convert a protobuf StateReason value to StateReason enum.\n    Args:\n        state_reason: State reason to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == state_reason for e in cls):\n_logger.warning(\n\"Unknown state reason %s. Returning UNSPECIFIED.\", state_reason\n)\nreturn cls.UNSPECIFIED\nreturn cls(state_reason)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.StateReason.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a StateReason enum to protobuf StateReason value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the StateReason enum.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(\nself,\n) -&gt; electricity_trading_pb2.OrderDetail.StateDetail.StateReason.ValueType:\n\"\"\"Convert a StateReason enum to protobuf StateReason value.\n    Returns:\n        Protobuf message corresponding to the StateReason enum.\n    \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade","title":"frequenz.client.electricity_trading.Trade  <code>dataclass</code>","text":"<p>Represents a private trade in the electricity market.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass Trade:  # pylint: disable=too-many-instance-attributes\n\"\"\"Represents a private trade in the electricity market.\"\"\"\nid: int\n\"\"\"ID of the trade.\"\"\"\norder_id: int\n\"\"\"ID of the corresponding order.\"\"\"\nside: MarketSide\n\"\"\"Indicates if the trade's order was on the Buy or Sell side of the\n    market.\"\"\"\ndelivery_area: DeliveryArea\n\"\"\"Delivery area of the trade.\"\"\"\ndelivery_period: DeliveryPeriod\n\"\"\"The delivery period for the contract.\"\"\"\nexecution_time: datetime\n\"\"\"UTC Timestamp of the trade's execution time.\"\"\"\nprice: Price\n\"\"\"The price at which the trade was executed.\"\"\"\nquantity: Energy\n\"\"\"The executed quantity of the trade.\"\"\"\nstate: TradeState\n\"\"\"Current state of the trade.\"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.execution_time.tzinfo is None:\nraise ValueError(\"Execution time must have timezone information\")\nif self.execution_time.tzinfo != timezone.utc:\n_logger.warning(\"Execution timenis not in UTC timezone. Converting to UTC.\")\nself.execution_time = self.execution_time.astimezone(timezone.utc)\n@classmethod\ndef from_pb(cls, trade: electricity_trading_pb2.Trade) -&gt; Self:\n\"\"\"Convert a protobuf Trade to Trade object.\n        Args:\n            trade: Trade to convert.\n        Returns:\n            Trade object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\nid=trade.id,\norder_id=trade.order_id,\nside=MarketSide.from_pb(trade.side),\ndelivery_area=DeliveryArea.from_pb(trade.delivery_area),\ndelivery_period=DeliveryPeriod.from_pb(trade.delivery_period),\nexecution_time=trade.execution_time.ToDatetime(tzinfo=timezone.utc),\nprice=Price.from_pb(trade.price),\nquantity=Energy.from_pb(trade.quantity),\nstate=TradeState.from_pb(trade.state),\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.Trade:\n\"\"\"Convert a Trade object to protobuf Trade.\n        Returns:\n            Protobuf message corresponding to the Trade object.\n        \"\"\"\nexecution_time = timestamp_pb2.Timestamp()\nexecution_time.FromDatetime(self.execution_time)\nreturn electricity_trading_pb2.Trade(\nid=self.id,\norder_id=self.order_id,\nside=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\ndelivery_area=self.delivery_area.to_pb(),\ndelivery_period=self.delivery_period.to_pb(),\nexecution_time=execution_time,\nprice=self.price.to_pb(),\nquantity=self.quantity.to_pb(),\nstate=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.delivery_area","title":"delivery_area  <code>instance-attribute</code>","text":"<pre><code>delivery_area: DeliveryArea\n</code></pre> <p>Delivery area of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.delivery_period","title":"delivery_period  <code>instance-attribute</code>","text":"<pre><code>delivery_period: DeliveryPeriod\n</code></pre> <p>The delivery period for the contract.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.execution_time","title":"execution_time  <code>instance-attribute</code>","text":"<pre><code>execution_time: datetime\n</code></pre> <p>UTC Timestamp of the trade's execution time.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int\n</code></pre> <p>ID of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.order_id","title":"order_id  <code>instance-attribute</code>","text":"<pre><code>order_id: int\n</code></pre> <p>ID of the corresponding order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.price","title":"price  <code>instance-attribute</code>","text":"<pre><code>price: Price\n</code></pre> <p>The price at which the trade was executed.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.quantity","title":"quantity  <code>instance-attribute</code>","text":"<pre><code>quantity: Energy\n</code></pre> <p>The executed quantity of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.side","title":"side  <code>instance-attribute</code>","text":"<pre><code>side: MarketSide\n</code></pre> <p>Indicates if the trade's order was on the Buy or Sell side of the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: TradeState\n</code></pre> <p>Current state of the trade.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.execution_time.tzinfo is None:\nraise ValueError(\"Execution time must have timezone information\")\nif self.execution_time.tzinfo != timezone.utc:\n_logger.warning(\"Execution timenis not in UTC timezone. Converting to UTC.\")\nself.execution_time = self.execution_time.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(trade: Trade) -&gt; Self\n</code></pre> <p>Convert a protobuf Trade to Trade object.</p> PARAMETER  DESCRIPTION <code>trade</code> <p>Trade to convert.</p> <p> TYPE: <code>Trade</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>Trade object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(cls, trade: electricity_trading_pb2.Trade) -&gt; Self:\n\"\"\"Convert a protobuf Trade to Trade object.\n    Args:\n        trade: Trade to convert.\n    Returns:\n        Trade object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\nid=trade.id,\norder_id=trade.order_id,\nside=MarketSide.from_pb(trade.side),\ndelivery_area=DeliveryArea.from_pb(trade.delivery_area),\ndelivery_period=DeliveryPeriod.from_pb(trade.delivery_period),\nexecution_time=trade.execution_time.ToDatetime(tzinfo=timezone.utc),\nprice=Price.from_pb(trade.price),\nquantity=Energy.from_pb(trade.quantity),\nstate=TradeState.from_pb(trade.state),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.Trade.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; Trade\n</code></pre> <p>Convert a Trade object to protobuf Trade.</p> RETURNS DESCRIPTION <code>Trade</code> <p>Protobuf message corresponding to the Trade object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.Trade:\n\"\"\"Convert a Trade object to protobuf Trade.\n    Returns:\n        Protobuf message corresponding to the Trade object.\n    \"\"\"\nexecution_time = timestamp_pb2.Timestamp()\nexecution_time.FromDatetime(self.execution_time)\nreturn electricity_trading_pb2.Trade(\nid=self.id,\norder_id=self.order_id,\nside=electricity_trading_pb2.MarketSide.ValueType(self.side.value),\ndelivery_area=self.delivery_area.to_pb(),\ndelivery_period=self.delivery_period.to_pb(),\nexecution_time=execution_time,\nprice=self.price.to_pb(),\nquantity=self.quantity.to_pb(),\nstate=electricity_trading_pb2.TradeState.ValueType(self.state.value),\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState","title":"frequenz.client.electricity_trading.TradeState","text":"<p>             Bases: <code>Enum</code></p> <p>State of a trade.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>class TradeState(enum.Enum):\n\"\"\"State of a trade.\"\"\"\nUNSPECIFIED = electricity_trading_pb2.TradeState.TRADE_STATE_UNSPECIFIED\n\"\"\"The state is not known.\"\"\"\nACTIVE = electricity_trading_pb2.TradeState.TRADE_STATE_ACTIVE\n\"\"\"The trade has been executed in the market.\"\"\"\nCANCEL_REQUESTED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCEL_REQUESTED\n\"\"\"A cancellation request for the trade has been submitted.\"\"\"\nCANCEL_REJECTED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCEL_REJECTED\n\"\"\"The trade cancellation request was rejected.\"\"\"\nCANCELED = electricity_trading_pb2.TradeState.TRADE_STATE_CANCELED\n\"\"\"The trade has been cancelled. This can occur due to a cancellation request by the market\n    participant, system, or market operator.\"\"\"\nRECALL = electricity_trading_pb2.TradeState.TRADE_STATE_RECALLED\n\"\"\"The trade has been recalled. This could be due to a system issue or a request from the market\n    participant or market operator.\"\"\"\nRECALL_REQUESTED = electricity_trading_pb2.TradeState.TRADE_STATE_RECALL_REQUESTED\n\"\"\"A recall request for the trade has been submitted.\"\"\"\nRECALL_REJECTED = electricity_trading_pb2.TradeState.TRADE_STATE_RECALL_REJECTED\n\"\"\"The trade recall request was rejected.\"\"\"\nAPPROVAL_REQUESTED = (\nelectricity_trading_pb2.TradeState.TRADE_STATE_APPROVAL_REQUESTED\n)\n\"\"\"An approval has been requested.\"\"\"\n@classmethod\ndef from_pb(\ncls, trade_state: electricity_trading_pb2.TradeState.ValueType\n) -&gt; \"TradeState\":\n\"\"\"Convert a protobuf TradeState value to TradeState enum.\n        Args:\n            trade_state: The trade state to convert.\n        Returns:\n            Enum value corresponding to the protobuf message.\n        \"\"\"\nif not any(e.value == trade_state for e in cls):\n_logger.warning(\n\"Unknown trade state %s. Returning UNSPECIFIED.\", trade_state\n)\nreturn cls.UNSPECIFIED\nreturn cls(trade_state)\ndef to_pb(self) -&gt; electricity_trading_pb2.TradeState.ValueType:\n\"\"\"Convert a TradeState enum to protobuf TradeState value.\n        Returns:\n            Protobuf message corresponding to the TradeState enum.\n        \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.ACTIVE","title":"ACTIVE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTIVE = TRADE_STATE_ACTIVE\n</code></pre> <p>The trade has been executed in the market.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.APPROVAL_REQUESTED","title":"APPROVAL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>APPROVAL_REQUESTED = TRADE_STATE_APPROVAL_REQUESTED\n</code></pre> <p>An approval has been requested.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCELED","title":"CANCELED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCELED = TRADE_STATE_CANCELED\n</code></pre> <p>The trade has been cancelled. This can occur due to a cancellation request by the market participant, system, or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCEL_REJECTED","title":"CANCEL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REJECTED = TRADE_STATE_CANCEL_REJECTED\n</code></pre> <p>The trade cancellation request was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.CANCEL_REQUESTED","title":"CANCEL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CANCEL_REQUESTED = TRADE_STATE_CANCEL_REQUESTED\n</code></pre> <p>A cancellation request for the trade has been submitted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL","title":"RECALL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL = TRADE_STATE_RECALLED\n</code></pre> <p>The trade has been recalled. This could be due to a system issue or a request from the market participant or market operator.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL_REJECTED","title":"RECALL_REJECTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL_REJECTED = TRADE_STATE_RECALL_REJECTED\n</code></pre> <p>The trade recall request was rejected.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.RECALL_REQUESTED","title":"RECALL_REQUESTED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECALL_REQUESTED = TRADE_STATE_RECALL_REQUESTED\n</code></pre> <p>A recall request for the trade has been submitted.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.UNSPECIFIED","title":"UNSPECIFIED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>UNSPECIFIED = TRADE_STATE_UNSPECIFIED\n</code></pre> <p>The state is not known.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(trade_state: ValueType) -&gt; 'TradeState'\n</code></pre> <p>Convert a protobuf TradeState value to TradeState enum.</p> PARAMETER  DESCRIPTION <code>trade_state</code> <p>The trade state to convert.</p> <p> TYPE: <code>ValueType</code> </p> RETURNS DESCRIPTION <code>'TradeState'</code> <p>Enum value corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls, trade_state: electricity_trading_pb2.TradeState.ValueType\n) -&gt; \"TradeState\":\n\"\"\"Convert a protobuf TradeState value to TradeState enum.\n    Args:\n        trade_state: The trade state to convert.\n    Returns:\n        Enum value corresponding to the protobuf message.\n    \"\"\"\nif not any(e.value == trade_state for e in cls):\n_logger.warning(\n\"Unknown trade state %s. Returning UNSPECIFIED.\", trade_state\n)\nreturn cls.UNSPECIFIED\nreturn cls(trade_state)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.TradeState.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; ValueType\n</code></pre> <p>Convert a TradeState enum to protobuf TradeState value.</p> RETURNS DESCRIPTION <code>ValueType</code> <p>Protobuf message corresponding to the TradeState enum.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.TradeState.ValueType:\n\"\"\"Convert a TradeState enum to protobuf TradeState value.\n    Returns:\n        Protobuf message corresponding to the TradeState enum.\n    \"\"\"\nreturn self.value\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder","title":"frequenz.client.electricity_trading.UpdateOrder  <code>dataclass</code>","text":"<p>Represents the order properties that can be updated after an order has been placed.</p> <p>At least one of the optional fields must be set for an update to take place.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@dataclass()\nclass UpdateOrder:  # pylint: disable=too-many-instance-attributes\n\"\"\"\n    Represents the order properties that can be updated after an order has been placed.\n    At least one of the optional fields must be set for an update to take place.\n    \"\"\"\nprice: Price | None = None\n\"\"\"The updated limit price at which the contract is to be traded.\n    This is the maximum price for a BUY order or the minimum price for a SELL order.\"\"\"\nquantity: Energy | None = None\n\"\"\"The updated quantity of the contract being traded, specified in MWh.\"\"\"\nstop_price: Price | None = None\n\"\"\"Applicable for STOP_LIMIT orders. This is the updated stop price that triggers\n    the limit order.\"\"\"\npeak_price_delta: Price | None = None\n\"\"\"Applicable for ICEBERG orders. This is the updated price difference\n    between the peak price and the limit price.\"\"\"\ndisplay_quantity: Energy | None = None\n\"\"\"Applicable for ICEBERG orders. This is the updated quantity of the order\n    to be displayed in the order book.\"\"\"\nexecution_option: OrderExecutionOption | None = None\n\"\"\"Updated execution options such as All or None, Fill or Kill, etc.\"\"\"\nvalid_until: datetime | None = None\n\"\"\"This is an updated timestamp defining the time after which the order should\n    be cancelled if not filled. The timestamp is in UTC.\"\"\"\npayload: dict[str, struct_pb2.Value] | None = None\n\"\"\"Updated user-defined payload individual to a specific order. This can be any data\n    that the user wants to associate with the order.\"\"\"\ntag: str | None = None\n\"\"\"Updated user-defined tag to group related orders.\"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.valid_until is not None:\nif self.valid_until.tzinfo is None:\nraise ValueError(\"Valid until must be a UTC datetime.\")\nif self.valid_until.tzinfo != timezone.utc:\n_logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\nself.valid_until = self.valid_until.astimezone(timezone.utc)\n@classmethod\ndef from_pb(\ncls,\nupdate_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n) -&gt; Self:\n\"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n        Args:\n            update_order: UpdateOrder to convert.\n        Returns:\n            UpdateOrder object corresponding to the protobuf message.\n        \"\"\"\nreturn cls(\nprice=Price.from_pb(update_order.price)\nif update_order.HasField(\"price\")\nelse None,\nquantity=Energy.from_pb(update_order.quantity)\nif update_order.HasField(\"quantity\")\nelse None,\nstop_price=Price.from_pb(update_order.stop_price)\nif update_order.HasField(\"stop_price\")\nelse None,\npeak_price_delta=Price.from_pb(update_order.peak_price_delta)\nif update_order.HasField(\"peak_price_delta\")\nelse None,\ndisplay_quantity=Energy.from_pb(update_order.display_quantity)\nif update_order.HasField(\"display_quantity\")\nelse None,\nexecution_option=OrderExecutionOption.from_pb(update_order.execution_option)\nif update_order.HasField(\"execution_option\")\nelse None,\nvalid_until=update_order.valid_until.ToDatetime(tzinfo=timezone.utc)\nif update_order.HasField(\"valid_until\")\nelse None,\npayload=json_format.MessageToDict(update_order.payload)\nif update_order.payload\nelse None,\ntag=update_order.tag if update_order.HasField(\"tag\") else None,\n)\ndef to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n\"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n        Returns:\n            Protobuf UpdateOrder corresponding to the object.\n        \"\"\"\nif self.valid_until:\nvalid_until = timestamp_pb2.Timestamp()\nvalid_until.FromDatetime(self.valid_until)\nelse:\nvalid_until = None\nreturn electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\nprice=self.price.to_pb() if self.price else None,\nquantity=self.quantity.to_pb() if self.quantity else None,\nstop_price=self.stop_price.to_pb() if self.stop_price else None,\npeak_price_delta=self.peak_price_delta.to_pb()\nif self.peak_price_delta\nelse None,\ndisplay_quantity=self.display_quantity.to_pb()\nif self.display_quantity\nelse None,\nexecution_option=(\nelectricity_trading_pb2.OrderExecutionOption.ValueType(\nself.execution_option.value\n)\nif self.execution_option\nelse None\n),\nvalid_until=valid_until if self.valid_until else None,\npayload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\ntag=self.tag if self.tag else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.display_quantity","title":"display_quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>display_quantity: Energy | None = None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated quantity of the order to be displayed in the order book.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.execution_option","title":"execution_option  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>execution_option: OrderExecutionOption | None = None\n</code></pre> <p>Updated execution options such as All or None, Fill or Kill, etc.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.payload","title":"payload  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>payload: dict[str, Value] | None = None\n</code></pre> <p>Updated user-defined payload individual to a specific order. This can be any data that the user wants to associate with the order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.peak_price_delta","title":"peak_price_delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>peak_price_delta: Price | None = None\n</code></pre> <p>Applicable for ICEBERG orders. This is the updated price difference between the peak price and the limit price.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.price","title":"price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>price: Price | None = None\n</code></pre> <p>The updated limit price at which the contract is to be traded. This is the maximum price for a BUY order or the minimum price for a SELL order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.quantity","title":"quantity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>quantity: Energy | None = None\n</code></pre> <p>The updated quantity of the contract being traded, specified in MWh.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.stop_price","title":"stop_price  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stop_price: Price | None = None\n</code></pre> <p>Applicable for STOP_LIMIT orders. This is the updated stop price that triggers the limit order.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag: str | None = None\n</code></pre> <p>Updated user-defined tag to group related orders.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.valid_until","title":"valid_until  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>valid_until: datetime | None = None\n</code></pre> <p>This is an updated timestamp defining the time after which the order should be cancelled if not filled. The timestamp is in UTC.</p>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder-functions","title":"Functions","text":""},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post initialization checks to ensure that all datetimes are UTC.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post initialization checks to ensure that all datetimes are UTC.\"\"\"\nif self.valid_until is not None:\nif self.valid_until.tzinfo is None:\nraise ValueError(\"Valid until must be a UTC datetime.\")\nif self.valid_until.tzinfo != timezone.utc:\n_logger.warning(\"Valid until is not a UTC datetime. Converting to UTC.\")\nself.valid_until = self.valid_until.astimezone(timezone.utc)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.from_pb","title":"from_pb  <code>classmethod</code>","text":"<pre><code>from_pb(update_order: UpdateOrder) -&gt; Self\n</code></pre> <p>Convert a protobuf UpdateOrder to UpdateOrder object.</p> PARAMETER  DESCRIPTION <code>update_order</code> <p>UpdateOrder to convert.</p> <p> TYPE: <code>UpdateOrder</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>UpdateOrder object corresponding to the protobuf message.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>@classmethod\ndef from_pb(\ncls,\nupdate_order: electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder,\n) -&gt; Self:\n\"\"\"Convert a protobuf UpdateOrder to UpdateOrder object.\n    Args:\n        update_order: UpdateOrder to convert.\n    Returns:\n        UpdateOrder object corresponding to the protobuf message.\n    \"\"\"\nreturn cls(\nprice=Price.from_pb(update_order.price)\nif update_order.HasField(\"price\")\nelse None,\nquantity=Energy.from_pb(update_order.quantity)\nif update_order.HasField(\"quantity\")\nelse None,\nstop_price=Price.from_pb(update_order.stop_price)\nif update_order.HasField(\"stop_price\")\nelse None,\npeak_price_delta=Price.from_pb(update_order.peak_price_delta)\nif update_order.HasField(\"peak_price_delta\")\nelse None,\ndisplay_quantity=Energy.from_pb(update_order.display_quantity)\nif update_order.HasField(\"display_quantity\")\nelse None,\nexecution_option=OrderExecutionOption.from_pb(update_order.execution_option)\nif update_order.HasField(\"execution_option\")\nelse None,\nvalid_until=update_order.valid_until.ToDatetime(tzinfo=timezone.utc)\nif update_order.HasField(\"valid_until\")\nelse None,\npayload=json_format.MessageToDict(update_order.payload)\nif update_order.payload\nelse None,\ntag=update_order.tag if update_order.HasField(\"tag\") else None,\n)\n</code></pre>"},{"location":"reference/frequenz/client/electricity_trading/#frequenz.client.electricity_trading.UpdateOrder.to_pb","title":"to_pb","text":"<pre><code>to_pb() -&gt; UpdateOrder\n</code></pre> <p>Convert a UpdateOrder object to protobuf UpdateOrder.</p> RETURNS DESCRIPTION <code>UpdateOrder</code> <p>Protobuf UpdateOrder corresponding to the object.</p> Source code in <code>src/frequenz/client/electricity_trading/_types.py</code> <pre><code>def to_pb(self) -&gt; electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder:\n\"\"\"Convert a UpdateOrder object to protobuf UpdateOrder.\n    Returns:\n        Protobuf UpdateOrder corresponding to the object.\n    \"\"\"\nif self.valid_until:\nvalid_until = timestamp_pb2.Timestamp()\nvalid_until.FromDatetime(self.valid_until)\nelse:\nvalid_until = None\nreturn electricity_trading_pb2.UpdateGridpoolOrderRequest.UpdateOrder(\nprice=self.price.to_pb() if self.price else None,\nquantity=self.quantity.to_pb() if self.quantity else None,\nstop_price=self.stop_price.to_pb() if self.stop_price else None,\npeak_price_delta=self.peak_price_delta.to_pb()\nif self.peak_price_delta\nelse None,\ndisplay_quantity=self.display_quantity.to_pb()\nif self.display_quantity\nelse None,\nexecution_option=(\nelectricity_trading_pb2.OrderExecutionOption.ValueType(\nself.execution_option.value\n)\nif self.execution_option\nelse None\n),\nvalid_until=valid_until if self.valid_until else None,\npayload=struct_pb2.Struct(fields=self.payload) if self.payload else None,\ntag=self.tag if self.tag else None,\n)\n</code></pre>"}]}